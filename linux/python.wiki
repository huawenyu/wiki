---
layout: post
title:  "git svn"
date:   2013-02-15 13:31:01 +0800
categories: linux
tags: cm
---

* content
{:toc}


# Quick Start

## python3 for ubuntu

### Suggest using the default python3 for ubuntu

Even install python3.6, the library is also using python3.4 when install by pip3.

### [Not suggest] Install Python 3.6 from J Fernyhough’s Personal Package Archive (PPA).

[Install python3.6](https://www.rosehosting.com/blog/how-to-install-python-3-6-on-ubuntu-16-04/)

```shell
    # Install the following requirements
    $ sudo apt-get install software-properties-common python-software-properties

    # Run the following command to add the PPA
    $ sudo add-apt-repository ppa:jonathonf/python-3.6
    Press [ENTER] to continue or ctrl-c to cancel adding it

    # update the repositories
    $ sudo apt-get update
    $ sudo apt-get install python3.6
    $ sudo apt-get install python3.6-dev
    $ sudo apt-get install python3.6-venv
    $ wget https://bootstrap.pypa.io/get-pip.py
    $ sudo python3.6 get-pip.py
    $ sudo ln -s /usr/bin/python3.6 /usr/local/bin/python3
    $ sudo ln -s /usr/local/bin/pip /usr/local/bin/pip3

    # Do this only if you want python3 to be the default Python
    # instead of python2 (may be dangerous, esp. before 2020):
    # sudo ln -s /usr/bin/python3.6 /usr/local/bin/python
    # Verify Python 3.6.3 installation on Ubuntu 16.04
    $ python3.6 -V
    Python 3.6.3
```

### Change system default to python3

From the comment: 

    sudo update-alternatives --config python
Will show you an error:

    update-alternatives: error: no alternatives for python3 

You need to update your `update-alternatives` , then you will be able to set your default python version.

    sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.4 1
    sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 2
Then run :

    sudo update-alternatives --config python
Set python3.6 as default. 

    $ python --version
    Python 3.6.3

### python3: modules rename
    
### module: ConfigParser
    In Python 3, ConfigParser has been renamed to configparser
    
    What worked for me in Ubuntu was actually just:

### module: tkinter
    
    For python 3.4:
    sudo apt-get install python3-tk
    
    For python 3.6:
    sudo apt-get install python3.6-tk
    
## Python shell

    bpython

## List installed packages

    >>> help("modules")

    So we can use it to check a package existed or not:
    $ python -c "help('modules');" | grep pexpect

## Install lib

    $ python setup.py install --user

    pip show pexpect
    ---
    Name: pexpect
    Version: 4.2.0
    Location: /usr/local/lib/python2.7/dist-packages
    Requires: ptyprocess

    >>> import statlib
    >>> print statlib.__version__

    >>> import construct
    >>> print contruct.__version__


# Snippets

## IpAddress & Integer

Python 3 has ipaddress module which features very simple conversion:

    import ipaddress
    int(ipaddress.IPv4Address("192.168.0.1"))
    str(ipaddress.IPv4Address(3232235521))

# Built-In Types

## List (string also list)

### [list operate][5]

```python
    a[start:end] # items start through end-1
    a[start:]    # items start through the rest of the array
    a[:end]      # items from the beginning through end-1
    a[:]         # a copy of the whole array
```

There is also the step value, which can be used with any of the above:

    a[start:end:step] # start through not past end, by step

The key point to remember is that the :end value represents the first value that is not in the selected slice. So, the difference beween end and start is the number of elements selected (if step is 1, the default).


The other feature is that start or end may be a negative number, which means it counts from the end of the array instead of the beginning. So:

    a[-1]    # last item in the array
    a[-2:]   # last two items in the array
    a[:-2]   # everything except the last two items

Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for a[:-2] and a only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.


Enumerating the possibilities allowed by the grammar:

    >>> seq[:]                # [seq[0],   seq[1],          ..., seq[-1]    ]
    >>> seq[low:]             # [seq[low], seq[low+1],      ..., seq[-1]    ]
    >>> seq[:high]            # [seq[0],   seq[1],          ..., seq[high-1]]
    >>> seq[low:high]         # [seq[low], seq[low+1],      ..., seq[high-1]]
    >>> seq[::stride]         # [seq[0],   seq[stride],     ..., seq[-1]    ]
    >>> seq[low::stride]      # [seq[low], seq[low+stride], ..., seq[-1]    ]
    >>> seq[:high:stride]     # [seq[0],   seq[stride],     ..., seq[high-1]]
    >>> seq[low:high:stride]  # [seq[low], seq[low+stride], ..., seq[high-1]]

Of course, if (high-low)%stride != 0, then the end point will be a little lower than high-1.


Extended slicing (with commas and ellipses) are mostly used only by special data structures (like Numpy); the basic sequences don't support them.

    >>> class slicee:
    ...     def __getitem__(self, item):
    ...         return `item`
    ...
    >>> slicee()[0, 1:2, ::5, ...]
    '(0, slice(1, 2, None), slice(None, None, 5), Ellipsis)'


## string

### trim

If you want to remove leading and ending spaces, use str.strip() :

    sentence = ' hello  apple'
    sentence.strip()
    >>> 'hello  apple'

If you want to remove all spaces, you can use str.replace():

    sentence = ' hello  apple'
    sentence.replace(" ", "")
    >>> 'helloapple'

If you want to remove duplicated spaces, use the str.split():

    sentence = ' hello  apple'
    " ".join(sentence.split())
    >>> 'hello apple'

### empty test

    if not myString:

## I/O oper


python open does not create file if it doesnt exist:

```python
    # Change "rw" to "w+", Or use 'a+' for appending (not erasing existing content)
    file = open('myfile.dat', 'rw')

    # create path
    filename = "/foo/bar/baz.txt"
    if not os.path.exists(os.path.dirname(filename)):
        os.makedirs(os.path.dirname(filename))
    with open(filename, "w+") as f:
        f.write("FOOBAR")
```

# enum

## python 3: already added

Enums have been added to Python 3.4 as described in PEP 435. ie.

```python

    from enum import Enum
    Animal = Enum('Animal', 'ant bee cat dog')

    # or equivalently:
    class Animals(Enum):
        ant = 1
        bee = 2
        cat = 3
        dog = 4
```

## python 2

In earlier versions, one way of accomplishing enums is:
```python

def enum(**enums):
    """
    >>> Numbers = enum(ONE=1, TWO=2, THREE='three')
    >>> Numbers.ONE
    1
    >>> Numbers.TWO
    2
    >>> Numbers.THREE
    'three'
    """
    return type('Enum', (), enums)
```

You can also easily support automatic enumeration with something like this:
```python

    def enum(*sequential, **named):
        enums = dict(zip(sequential, range(len(sequential))), **named)
        return type('Enum', (), enums)

    # Support for converting the values back to names can be added this way:
    def enum(*sequential, **named):
        enums = dict(zip(sequential, range(len(sequential))), **named)
        reverse = dict((value, key) for key, value in enums.iteritems())
        enums['reverse_mapping'] = reverse
        return type('Enum', (), enums)
```


This overwrites anything with that name, but it is useful for rendering your enums in output. It will throw KeyError if the reverse mapping doesn't exist. With the first example:
and used like so:

from name to int
>>> Numbers = enum('ZERO', 'ONE', 'TWO')
>>> Numbers.ZERO
0
>>> Numbers.ONE
1


from enum to name
>>> Numbers.reverse_mapping[Numbers.ONE]
'ONE'

## python 2: My prefer implement use dict
```python

def numbers_to_strings(argument):
    switcher = {
        0: "zero",
        1: "one",
        2: "two",
    }
    return switcher.get(argument, "nothing")

This code is analogous to:

function(argument){
    switch(argument) {
        case 0:
            return "zero";
        case 1:
            return "one";
        case 2:
            return "two";
        default:
            return "nothing";
    };
};
```
While the Python code is often more terse than the standard method of handling cases, I could argue it is more arcane. When I first started Python it felt weird and distracting. Over time it grew on me, the use of a dictionary key being the identifier in a switch becoming more and more habitual.

## Dictionary Mapping for Functions

In Python we can also include functions or lambdas in our dictionary mapping:
```python

def zero():
    return "zero"

def one():
    return "one"

def numbers_to_functions_to_strings(argument):
    switcher = {
        0: zero,
        1: one,
        2: lambda: "two",
    }
    # Get the function from switcher dictionary
    func = switcher.get(argument, lambda: "nothing")
    # Execute the function
    return func()
```

While the code inside zero() and one are simple, many Python programs use dictionary mappings like this to dispatch complex procedures.

## Dispatch Methods for Classes

If we don't know what method to call on a class, we can use a dispatch method to determine it at runtime.
```python

class Switcher(object):
    def numbers_to_methods_to_strings(self, argument):
        """Dispatch method"""
        # prefix the method_name with 'number_' because method names
        # cannot begin with an integer.
        method_name = 'number_' + str(argument)
        # Get the method from 'self'. Default to a lambda.
        method = getattr(self, method_name, lambda: "nothing")
        # Call the method as we return it
        return method()

    def number_0(self):
        return "zero"

    def number_1(self):
        return "one"

    def number_2(self):
        return "two"
```

# Class idioms

To understand why what you wrote failed, you need to know a little bit about how class definitions work in Python. As you may know, Python is an interpreted language: there is a program which reads through Python files and executes them as it goes. When the interpreter encounters a class definition, it does the following:

Creates a new namespace (record of all the variable names) in which the class variables and methods will be stored.
Extracts all the code within the class definition (as determined by its indentation) and runs that code. This will populate the namespace which it just created.
Creates a new class object whose namespace is that given above, and with base classes those given in the definition.
Binds the name of the class to this object.
So what happened when you indented the main function inside your code? While inside step 2, you referred to the name Animal. But this name isn't defined until step 4! Indeed, it can't be defined at the stage you referred to it, because that would be circular. When you move main outside of the class definition, it won't be executed until after steps 1-4 have been completed, and hence the name Animal will already be bound.

By the way, the code you have written is not good Python. You should probably try to find a better tutorial; the usual recommendation is "Dive Into Python". I've rewritten it as it should be done:

## define style

### Style 1: easier like C, I perfer

```python
  class Animal(object):
      def __init__(self, hungry="yes", name=None, owner=None):
          self.hungry = hungry
          self.name = name
          self.owner = owner


      def noise(self):
          print('errr')


      def _internal_method(self):
          print("hard to find")


  if  __name__ =='__main__':
      dog = Animal()    
      dog.owner = 'Sue'
      print dog.owner
      dog.noise()
```

### Style 2: more like Java

```python
class Animal:
    __hungry = "yes"
    __name = "no name"
    __owner = "no owner"

    def __init__(self):
        pass

    def set_owner(self,newOwner):
        self.__owner= newOwner
        return

    def get_owner(self):
        return self.__owner

    def set_name(self,newName):
        self.__name= newName
        return

    def get_name(self):
        return self.__name

    def noise(self):
        print('errr')
        return

    def __hiddenmethod(self):
        print("hard to find")

def main():        # should not be in the class. When you take it outside (no indent) it should work.
    dog = Animal()    
    dog.set_owner('Sue')
    print dog.get_owner()
    dog.noise()

if  __name__ =='__main__':
    main()
```

## class member & static member

Both ways aren't correct or incorrect, they are just two different kind of class elements:


Elements outside the __init__ method are static elements, it means, they belong to the class, and share by all instance, we can access it event use ClassName.
Elements inside the __init__ method are elements of the object (self), but every object have their independable memory event they have same value, we must by object to access it.

You'll see it more clearly with some code:

```python
    class MyClass:
        static_elem = 123

        def __init__(self):
            self.object_elem = 456

        def setup():
            """
            >>> print c1.static_elem, c1.object_elem
            123 456
            >>> print c2.static_elem, c2.object_elem
            123 456

            # Let's try changing the static element
            MyClass.static_elem = 999
            >>> print c1.static_elem, c1.object_elem
            999 456
            >>> print c2.static_elem, c2.object_elem
            999 456

            # Now, let's try changing the object element
            >>> c1.object_elem = 888
            >>> print c1.static_elem, c1.object_elem
            999 888
            >>> print c2.static_elem, c2.object_elem
            999 456
            # As you can see, when we changed the class element, it changed for both objects.
            # But, when we changed the object element, the other object remained unchanged.
            """

            c1 = MyClass()
            c2 = MyClass()

    if  __name__ =='__main__':
        main()

    if __name__ == os.path.splitext(os.path.basename(__file__))[0]:
        setup()
```
## class static method

    class MyClass(object):
        @staticmethod
        def the_static_method(x):
            print x

    MyClass.the_static_method(2) # outputs 2


## class inheritage


This simple example will show you how to inherit a class from a parent class. I have to apologise for some grammar mistakes that I've probably put in the comments, but English is not my native language.

output:

    Here comes Lois Lane
    Here comes Jimmy Olsen
    Here comes Clark Kent
    ...but his secret identity is 'Superman' and he's a super-hero!
    --> Let's see what a man can do:
    Jimmy Olsen walks
    Lois Lane says: 'Oh no, we're in danger!'
    --> Let's see what a superman can do:
    Clark Kent walks
    Clark Kent says: 'This is a job for SUPERMAN!'
    Superman run at the speed of light
    Superman fly up in the sky
    Superman uses his x-ray vision

```python
    #!/usr/bin/env python

    class man(object):

        # name of the man
        name = ""

        def __init__(self, P_name):
            """ Class constructor """
            self.name = P_name
            print("Here comes " + self.name)

        def talk(self, P_message):
            print(self.name + " says: '" + P_message + "'")

        def walk(self):
            """ This let an instance of a man to walk """
            print(self.name + " walks")

    # This class inherits from Man class
    # A superman has all the powers of a man (A.K.A. Methods and Properties in our case ;-)
    class superman(man):

        # Name of his secret identity
        secret_identity = ""

        def __init__(self, P_name, P_secret_identity):
            """ Class constructor that overrides its parent class constructor"""
            # Invokes the class constructor of the parent class #
            super(superman, self).__init__(P_name)
            # Now let's add a secret identity
            self.secret_identity = P_secret_identity
            print("...but his secret identity is '" + self.secret_identity + "' and he's a super-hero!")

        def walk(self, P_super_speed = False):
            # Overrides the normal walk, because a superman can walk at a normal
            # pace or run at the speed of light!
            if (not P_super_speed): super(superman, self).walk()
            else: print(self.secret_identity + " run at the speed of light")

        def fly(self):
            """ This let an instance of a superman to fly """
            # No man can do this!
            print(self.secret_identity + " fly up in the sky")

        def x_ray(self):
            """ This let an instance of a superman to use his x-ray vision """
            # No man can do this!
            print(self.secret_identity + " uses his x-ray vision")


    # Declare some instances of man and superman
    lois = man("Lois Lane")
    jimmy = man("Jimmy Olsen")
    clark = superman("Clark Kent", "Superman")

    # Let's puth them into action!

    print("\n--> Let's see what a man can do:\n")
    jimmy.walk()
    lois.talk("Oh no, we're in danger!")

    print("\n--> Let's see what a superman can do:\n")
    clark.walk()
    clark.talk("This is a job for SUPERMAN!")
    clark.walk(True)
    clark.fly()
    clark.x_ray()
```

### What does `if __name__ == “__main__”:` do?


When the Python interpreter reads a source file, it executes all of the code found in it. Before executing the code, it will define a few special variables. For example, if the python interpreter is running that module (the source file) as the main program, it sets the special __name__ variable to have a value "__main__". If this file is being imported from another module, __name__ will be set to the module's name.

In the case of your script, let's assume that it's executing as the main function, e.g. you said something like

    python threading_example.py

on the command line. After setting up the special variables, it will execute the import statement and load those modules. It will then evaluate the def block, creating a function object and creating a variable called myfunction that points to the function object. It will then read the if statement and see that __name__ does equal "__main__", so it will execute the block shown there.

One of the reasons for doing this is that sometimes you write a module (a .py file) where it can be executed directly. Alternatively, it can also be imported and used in another module. By doing the main check, you can have that code only execute when you want to run the module as a program and not have it execute when someone just wants to import your module and call your functions themselves.

# parameters ** (double star/asterisk)

[What does ** (double star/asterisk) and * (star/asterisk) do for parameters?](https://stackoverflow.com/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters)

The `*args` and `**kwargs` is a common idiom to allow arbitrary number of arguments to functions as described in the section [more on defining functions][1] in the Python documentation.

The `*args` will give you all function parameters [as a tuple][2]:

```python
    In [1]: def foo(*args):
       ...:     for a in args:
       ...:         print a
       ...:         
       ...:         
    
    In [2]: foo(1)
    1
    
    
    In [4]: foo(1,2,3)
    1
    2
    3
```
The `**kwargs` will give you all 
**keyword arguments** except for those corresponding to a formal parameter as a dictionary.

```python
    In [5]: def bar(**kwargs):
       ...:     for a in kwargs:
       ...:         print a, kwargs[a]
       ...:         
       ...:         
    
    In [6]: bar(name='one', age=27)
    age 27
    name one
```
Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:

    def foo(kind, *args, **kwargs):
       pass

Another usage of the `*l` idiom is to **unpack argument lists** when calling a function.

```python
    In [9]: def foo(bar, lee):
       ...:     print bar, lee
       ...:     
       ...:     
    
    In [10]: l = [1,2]
    
    In [11]: foo(*l)
    1 2
```
In Python 3 it is possible to use `*l` on the left side of an assignment ([Extended Iterable Unpacking][3]), though it gives a list instead of a tuple in this context:

```python
    first, *rest = [1,2,3,4]
    first, *l, last = [1,2,3,4]
```
Also Python 3 adds new semantic (refer [PEP 3102](https://www.python.org/dev/peps/pep-3102/)):

    def func(arg1, arg2, arg3, *, kwarg1, kwarg2):
        pass

Such function accepts only 3 positional arguments, and everything after `*` can only be passed as keyword arguments.

## pass multiple argument

It's also worth noting that you can use `*` and `**` when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function:

```python
    def foo(x,y,z):
        print("x=" + str(x))
        print("y=" + str(y))
        print("z=" + str(z))
```
You can do things like:

```python
    >>> mylist = [1,2,3]
    >>> foo(*mylist)
    x=1
    y=2
    z=3

    >>> mydict = {'x':1,'y':2,'z':3}
    >>> foo(**mydict)
    x=1
    y=2
    z=3

    >>> mytuple = (1, 2, 3)
    >>> foo(*mytuple)
    x=1
    y=2
    z=3
```
Note: The keys in `mydict` have to be named exactly like the parameters of function `foo`. Otherwise it will throw a `TypeError`:

```python
    >>> mydict = {'x':1,'y':2,'z':3,'badnews':9}
    >>> foo(**mydict)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: foo() got an unexpected keyword argument 'badnews'
```

# Design Pattern: Observer

Well... actually, this looks like a good design to me if an asynchronous API is what you want. It usually is. Maybe all you need is to switch from stderr to Python's [`logging`][1] module, which has a sort of publish/subscribe model of its own, what with `Logger.addHandler()` and so on.

If you do want to support observers, my advice is to keep it simple. You really only need a few lines of code.

```python
    class Event(object):
        pass

    class Observable(object):
        def __init__(self):
            self.callbacks = []
        def subscribe(self, callback):
            self.callbacks.append(callback)
        def fire(self, **attrs):
            e = Event()
            e.source = self
            for k, v in attrs.iteritems():
                setattr(e, k, v)
            for fn in self.callbacks:
                fn(e)
```

Your Job class can subclass `Observable`. When something of interest happens, call `self.fire(type="progress", percent=50)` or the like.


# TroubleShooting

## unittest: doctest

Doctest will parse the while script and then execute the doctest part, sample with filename onetest.py

```python
    class Something:
        Linux, DutKVM, DutOS, DutX, DutNone = range(5)

        @staticmethod
        def echoStr(t):
            """
            >>> dog.owner
            'Sue'
            """
            return "hello"


    class Animal:
        hungry = "yes"
        name = "no name"
        owner = "no owner"

        def __init__(self):
            pass


    # the doctest have __name__ of the current file without extention
    if __name__ == os.path.splitext(os.path.basename(__file__))[0]:
        dog = Animal()
        dog.owner = 'Sue'
```

## trace: echo each line when run

    $ python -m trace --trace my_script.py | grep my_script.py

# Lambda

Are you talking about lambda functions? Like `f = lambda x: x**2 + 2*x - 5`  Those things are actually quite useful.

Python supports a style of programming called functional programming where you can pass functions to other functions to do stuff. Example:

```python
    # sets mult3 to [3, 6, 9], those elements of the original list that are multiples of 3.
    def filterfunc(x):
        return x % 3 == 0
    mult3 = filter(filterfunc, [1, 2, 3, 4, 5, 6, 7, 8, 9])

    # This is shorter (and, one could argue, clearer) than
    mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])
```

Define a function that takes a mark and returns a human readable representation, you can use larsmans's expression or this one:

```python
    # Use string.format to format each entry and map to iterate over all of them:
    def grade(i):
        if i<40: return "Fail"
        if i>75: return "A++"
        if i>50: return "A"

    li = map(lambda x: "{0} - {1}".format(x, grade(x)), s)

    # The resulting list now contains strings in the desired format.

    >>> for i in li: print i
    50 - None
    62 - A
    15 - Fail
    76 - A++
    57 - A
    97 - A++
    82 - A++
    99 - A++
    45 - None
    23 - Fail
```

# Import package and module

File structure:
```sh
\
util                                <<< package
  utils.py                          <<< modules
modules                             <<< package, if the dir have __init__.py
  __init__.py
  modules1.py                       <<< modules
  submodule
     __init__.py
     submodule.py
```

for example, now I run the python interpreter in \ level, how to import modules utils.py?

## insert path

By default, you can't. When importing a file, Python only searches the current directory,
the directory that the entry-point script is running from,
and sys.path which includes locations such as the package installation directory
(it's actually a little more complex than this, but this covers most cases).

However, you can add to the Python path at runtime:

    # some_file.py
    import sys
    sys.path.insert(0, '/path/to/application/app/folder')
    
    import file


## What is __init__.py for?


Files name __init__.py are used to mark directories on disk as Python package directories. If you have the files

mydir/spam/__init__.py
mydir/spam/module.py

and mydir is on your path, you can import the code in module.py as
```python
    import spam.module

    or

    from spam import module
```

If you remove the __init__.py file, Python will no longer look for submodules inside that directory, so attempts to import the module will fail.
The __init__.py file is usually empty, but can be used to export selected portions of the package under more convenient name, hold convenience functions, etc.

Given the example above, the contents of the init module can be accessed as

```python
    import spam
```

## How to use __init__.py


The vast majority of the __init__.py files I write are empty, because many packages don't have anything to initialize.
One example in which I may want initialization is when at package-load time I want to read in a bunch of data once and for all (from files, a DB, or the web, say)
    -- in which case it's much nicer to put that reading in a private function in the package's __init__.py
    rather than have a separate "initialization module" and redundantly import that module from every single real module in the package (uselessly repetitive and error-prone: that's obviously a case in which relying on the language's guarantee that the package's __init__.py is loaded once before any module in the package is obviously much more Pythonic!).

For other concrete and authoritative expressions of opinion,
    look at the different approaches taken in the various packages that are part of Python's standard library.




## Import a module from a relative path


How do I import a python module given its relative path?


For example, if dirFoo contains Foo.py and dirBar, and dirBar contains Bar.py, how do I import Bar.py into Foo.py?


Here's a visual representation:


dirFoo\
    Foo.py
    dirBar\
        Bar.py
Foo wishes to include Bar, but restructuring the folder heirarchy is not an option.


Answer:


Assuming that both your directories are real python packages (do have the __init__.py file inside them), here is a safe solution for inclusion of modules relatively to the location of the script.


I assume that you want to do this because you need to include a set of modules with your script. I use this in production in several products and works in many special scenarios like: scripts called from another directory or executed with python execute instead of opening a new interpreter.


 import os, sys, inspect
 # realpath() with make your script run, even if you symlink it :)
 cmd_folder = os.path.realpath(os.path.abspath(os.path.split(inspect.getfile( inspect.currentframe() ))[0]))
 if cmd_folder not in sys.path:
     sys.path.insert(0, cmd_folder)


 # use this if you want to include modules from a subforder
 cmd_subfolder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"subfolder")))
 if cmd_subfolder not in sys.path:
     sys.path.insert(0, cmd_subfolder)


 # Info:
 # cmd_folder = os.path.dirname(os.path.abspath(__file__)) # DO NOT USE __file__ !!!
 # __file__ fails if script is called in different ways on Windows
 # __file__ fails if someone does os.chdir() before
 # sys.argv[0] also fails because it doesn't not always contains the path
As a bonus, this approach does let you force Python to use your module instead of the ones installed on the system.


Warning! I don't really know what is happening when current module is inside an egg file. Probably it fails too. Add a comment if you really need a better solution, I may invest few more hours in improving it.




import package
If you are developping a python package (what you are obviously doing, as you have __init__.py), then the most simple way to import your module is just via the package. For example, if your package is called mypackage, then:


import mypackage.utils


Another sample:


FooPackage/
  __init__.py
  foo.py


import the submodule:
import FooPackage.foo


What you're doing is looking for foo in FooPackage/__init__.py. You could solve it by putting import FooPackage.foo as foo (or from . import foo) in FooPackage/__init__.py, then Python will be able to find foo there. But I recommend using my first suggestion.


When you import FooPackage, Python searches the directories on PYTHONPATH until it 
* finds a file called FooPackage.py 
* or a directory called FooPackage containing a file called __init__.py
However, having found the package directory, it does not then scan that directory and automatically import all .py files. There are two reasons for this behaviour. 
* The first is that importing a module executes Python code which may take time, memory, or have side effects. So you might want to import a.b.c.d without necessarily importing all of a huge package a. It's up to the package designer to decide whether a's __init__.py explicitly imports its modules and subpackages so that they are always available, or whether or leaves the client program the ability to pick and choose what is loaded.
* The second is a bit more subtle, and also a showstopper. Without an explicit import statement (either in FooPackage/__init__.py or in the client program), Python doesn't necessarily know what name it should import foo.py as. On a case insensitive file system (such as used in Windows), this could represent a module named foo, Foo, FOO, fOo, foO, FoO, FOo, or fOO. All of these are valid, distinct Python identifiers, so Python just doesn't have enough information from the file alone to know what you mean. Therefore, in order to behave consistently on all systems, it requires an explicit import statement somewhere to clarify the name, even on file systems where full case information is available.


## how to find module source-code's path

### method 1: __file__

For modules coming from .py (or .pyc) files, you can use mymodule.__file__, e.g.

> import random
> random.__file__
'C:\\Python25\\lib\\random.pyc'


### method 2: python -v

Running python -v from the command line should tell you what is being imported and from where. This works for me on Windows and Mac OS X.

```
    C:\>python -v
    # installing zipimport hook
    import zipimport # builtin
    # installed zipimport hook
    # C:\Python24\lib\site.pyc has bad mtime
    import site # from C:\Python24\lib\site.py
    # wrote C:\Python24\lib\site.pyc
```

# What's the python __all__ module level variable for?

It has two purposes:
  - Anybody who reads the source will know what the exposed public API is. It doesn't prevent them from poking around in private declarations, but does provide a good warning not to.
  - When using from mod import *, only names listed in __all__ will be imported. This is not as important, in my opinion, because importing everything is a really bad idea.

Linked to, but not explicitly mentioned here, is exactly when __all__ is used. It is a list of strings defining what symbols in a module will be exported when from <module> import * is used on the module.


For example, the following code in a foo.py explicitly exports the symbols bar and baz:

```python
    __all__ = ['bar', 'baz']

    waz = 5
    bar = 10

    def baz():
        return 'baz'

    # These symbols can then be imported like so:
    from foo import *

    print bar
    print baz

    # The following will trigger an exception, as "waz" is not exported by the module
    print waz
```

If the __all__ above is commented out, this code will then execute to completion, as the default behaviour of import * is to import all symbols that do not begin with an underscore, from the given namespace.

It's important to note that __all__ only affects the behavior of from <module> import *. Members that are not mentioned in __all__ as still accessible from outside the module and can be imported with from <module> import <member>.

# Mix

## Python's state machine

http://www.ibm.com/developerworks/linux/library/l-python-state/index.html
http://code.activestate.com/recipes/578344-simple-finite-state-machine-class-v2/
https://github.com/oxplot/fysom/blob/master/fysom.py


  [1]: http://python4java.necaiseweb.org/Main/TableOfContents
  [2]: http://www.pycopia.net/
  [3]: http://infinitemonkeycorps.net/docs/pph/
  [4]: http://docs.python-guide.org/en/latest/writing/structure/
  [5]: http://effbot.org/zone/python-list.htm

