# Quick Start

## env & version

https://amaral.northwestern.edu/resources/guides/pyenv-tutorial

### pyenv Install
```sh
    git clone git://github.com/yyuu/pyenv.git .pyenv
    echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.bashrc
    echo 'export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.bashrc
    echo 'eval "$(pyenv init -)"' >> ~/.bashrc
    source ~/.bashrc

    <or> === oneline installer

    curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash
```

### workflow: pyenv

1. Switch global version:

```sh
    $ pyenv global
        system

    $ pyenv versions
        * system (set by /home/staff/jmoreira/.pyenv/version)

    $ pyenv install 3.4.0
    $ pyenv versions
        * system (set by /home/staff/jmoreira/.pyenv/version)
          3.4.0

    $ pyenv global 3.4.0        <<< To use python 3.4 as the global one
```
2. Set local version:

You can also use pyenv to define a project-specific, or local, version of Python

```sh
    $ pyenv global system
        Python 2.7.6

    $ mkdir cuting_edge
    $ cd cuting_edge/
    $ pyenv local 3.4.0
    $ python -V
        Python 3.4.0
    $ cd ..
    $ python -V
        Python 2.7.6
```

### pyenv-virtualenv

To other `virtualenv` users, the idea of a local Python might seem familiar.
Indeed, a local Python created from pyenv is almost like a Python virtual environment.

The main difference is that:
  - pyenv actually copies an entire Python installation every time you create a new pyenv version.
  - In contrast, virtualenv makes use of symbolic links to decrease the size of the virtualenv’s.

If you can’t function without your virtual environments anymore then fear not, for there is a plugin for that: pyenv-virtualenv.

### pyenv-virtualenv Install

git clone https://github.com/yyuu/pyenv-virtualenv.git ~/.pyenv/plugins/pyenv-virtualenv
source ~/.bashrc

### workflow: pyenv-virtualenv

```sh
    $ mkdir virtual_env
    $ cd virtual_env/
    $ pyenv virtualenv 3.4.0 venv       <<< Install a new version 3.4.0 and named as 'venv'
        Ignoring indexes: https://pypi.python.org/simple/
        Requirement already satisfied (use --upgrade to upgrade): setuptools in /home/staff/jmoreira/.pyenv/versions/venv/lib/python3.4/site-packages
        Requirement already satisfied (use --upgrade to upgrade): pip in /home/staff/jmoreira/.pyenv/versions/venv/lib/python3.4/site-packages
        Cleaning up...

    $ pyenv versions
    * system (set by /home/staff/jmoreira/.pyenv/version)
      3.4.0
      lab_web
      venv

    $ pyenv activate venv
    (venv) $ python -V
            Python 3.4.0

    (venv) $ pip list
            pip (1.5.4)
            setuptools (2.1)

    (venv) $ pyenv deactivate
            ~/virtual_env
```

Here I used Python 3.4 to create the virtualenv
(Note that if you want to create a virtualenv from the system Python,
 then virtualenv needs to be installed at the system level as well).

This last command is the recommended way to deactivate the virtualenv. This ensures that pyenv remains working as normal after you leave the virtualenv.

pyenv’s magic works because it actually redefines your Python command:

```sh
    ~$ which python
    /home/staff/jmoreira/.pyenv/shims/python
```
When you try to run Python, it first looks for a .python-version in the current directory to decide which version of python to run. If it doesn’t find this file, then it looks for the user-level file ~/.pyenv/version.

## pip install: ImportError: cannot import name main

Try re-install fix it or not:
```sh
    sudo python -m pip uninstall pip && sudo apt install python-pip --reinstall
```

Change /usr/bin/pip from
```python
from pip import main
if __name__ == '__main__':
    sys.exit(main())
```

To

```python
from pip import __main__
if __name__ == '__main__':
    sys.exit(__main__._main())
```

### python3: modules rename

### module: ConfigParser
    In Python 3, ConfigParser has been renamed to configparser

    What worked for me in Ubuntu was actually just:

### module: tkinter

    For python 3.4:
    sudo apt-get install python3-tk

    For python 3.6:
    sudo apt-get install python3.6-tk

## Lint

    sudo pip install pylint
    pylint --disable=all --enable=similarities <your-python-src-dir>

## Python shell

    bpython

## List installed packages

    >>> help("modules")

    So we can use it to check a package existed or not:
    $ python -c "help('modules');" | grep pexpect

## Install lib

    $ python setup.py install --user

    pip show pexpect
    ---
    Name: pexpect
    Version: 4.2.0
    Location: /usr/local/lib/python2.7/dist-packages
    Requires: ptyprocess

    >>> import statlib
    >>> print statlib.__version__

    >>> import construct
    >>> print contruct.__version__

# Modules_and_Packages

  https://www.learnpython.org/en/Modules_and_Packages

# Decorator

  https://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html

  https://www.artima.com/weblogs/viewpost.jsp?thread=240808
  [Decorator with args/class](https://dev.to/apcelent/python-decorator-tutorial-with-example-529f)
  https://www.geeksforgeeks.org/class-as-decorator-in-python/

```python
    # Python program to execute
    # time of a program

    # importing time module
    from time import time
    class Timer:

        def __init__(self, func):
            self.function = func

        def __call__(self, *args, **kwargs):
            start_time = time()
            result = self.function(*args, **kwargs)
            end_time = time()
            print("Execution took {} seconds".format(end_time-start_time))
            return result


    # adding a decorator to the class
    @Timer
    def some_function(delay):
        from time import sleep

        # Introducing some time delay to
        # simulate a time taking function.
        sleep(delay)

    some_function(3)
```

# yield/generators/iterables

  https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do

The `yield` is a keyword that is used like return, except the function will return a `generator`.
The `yield` statement suspends function's execution and sends a value back to caller,
    but retains enough state to enable function to resume where it is left off.
    When resumed, the function continues execution immediately after the last `yield` run.
This allows its code to produce a series of values over time, rather them computing them at once and sending them back like a list.

Let's see with an example:
```python
    # A Simple Python program to demonstrate working
    # of yield

    # A generator function that yields 1 for first time,
    # 2 second time and 3 third time
    def simpleGeneratorFun():
        yield 1
        yield 2
        yield 3

    # Driver code to check above generator function
    for value in simpleGeneratorFun():
        print(value)

    """
    Output:
    ================================
    1
    2
    3
    """
```


Return sends a specified value back to its caller whereas Yield can produce a sequence of values. We should use yield when we want to iterate over a sequence, but don’t want to store the entire sequence in memory.

Yield are used in Python generators. A generator function is defined like a normal function, but whenever it needs to generate a value, it does so with the yield keyword rather than return. If the body of a def contains yield, the function automatically becomes a generator function.

```python
    # A Python program to generate squares from 1
    # to 100 using yield and therefore generator

    # An infinite generator function that prints
    # next square number. It starts with 1
    def nextSquare():
        i = 1;

        # An Infinite loop to generate squares
        while True:
            yield i*i
            i += 1  # Next execution resumes
                    # from this point

    # Driver code to test above generator
    # function
    for num in nextSquare():
        if num > 100:
             break
        print(num)

    """
    Output:
    =================
    1
    4
    9
    16
    25
    36
    49
    64
    81
    100
    """
```

## Shortcut to understanding `yield` ##

When you see a function with `yield` statements, apply this easy trick to understand what will happen:

 1. Insert a line `result = []` at the start of the function.
 2. Replace each `yield expr` with `result.append(expr)`.
 3. Insert a line `return result` at the bottom of the function.
 4. Yay - no more `yield` statements! Read and figure out code.
 5. Compare function to original definition.

This trick may give you an idea of the logic behind the function, but what actually happens with `yield` is significantly different that what happens in the list based approach. In many cases the yield approach will be a lot more memory efficient and faster too. In other cases this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...

## Don't confuse your Iterables, Iterators and Generators

First, the **iterator protocol** - when you write

    for x in mylist:
        ...loop body...

Python performs the following two steps:

1. Gets an iterator for `mylist`:

   Call `iter(mylist)` -> this returns an object with a `next()` method (or `__next__()` in Python 3).

   [This is the step most people forget to tell you about]

2. Uses the iterator to loop over items:

   Keep calling the `next()` method on the iterator returned from step 1. The return value from `next()` is assigned to `x` and the loop body is executed. If an exception `StopIteration` is raised from within `next()`, it means there are no more values in the iterator and the loop is exited.

The truth is Python performs the above two steps anytime it wants to *loop over* the contents of an object - so it could be a for loop, but it could also be code like `otherlist.extend(mylist)` (where `otherlist` is a Python list).

Here `mylist` is an *iterable* because it implements the iterator protocol. In a user defined class, you can implement the `__iter__()` method to make instances of your class iterable. This method should return an *iterator*. An iterator is an object with a `next()` method. It is possible to implement both `__iter__()` and `next()` on the same class, and have `__iter__()` return `self`. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.

So that's the iterator protocol, many objects implement this protocol:

 1. Built-in lists, dictionaries, tuples, sets, files.
 2. User defined classes that implement `__iter__()`.
 3. Generators.

Note that a `for` loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls `next()`. Built-in lists return their items one by one, dictionaries return the *keys* one by one, files return the *lines* one by one, etc. And generators return... well that's where `yield` comes in:

    def f123():
        yield 1
        yield 2
        yield 3

    for item in f123():
        print item

Instead of `yield` statements, if you had three `return` statements in `f123()` only the first would get executed, and the function would exit. But `f123()` is no ordinary function. When `f123()` is called, it *does not* return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the `for` loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the `yield` it previously returned from, executes the next line of code, in this case a `yield` statement, and returns that as the next item. This happens until the function exits, at which point the generator raises `StopIteration`, and the loop exits.

So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing `__iter__()` and `next()` methods to keep the `for` loop happy. At the other end however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode.

## Why Use Generators?

Usually you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class `SomethingIter` that keeps state in instance members and performs the next logical step in it's `next()` (or `__next__()` in Python 3) method. Depending on the logic, the code inside the `next()` method may end up looking very complex and be prone to bugs. Here generators provide a clean and easy solution.

# python CLI modules

Which require from myself dut_control.py and create a interactive prompt interface for our dut's troubleshooing.

## Using basic lib `cmd`

```python
from cmd import Cmd

class MyPrompt(Cmd):

    def do_hello(self, args):
        """Says hello. If you provide a name, it will greet you with it."""
        if len(args) == 0:
            name = 'stranger'
        else:
            name = args
        print "Hello, %s" % name

    def do_quit(self, args):
        """Quits the program."""
        print "Quitting."
        raise SystemExit


if __name__ == '__main__':
    prompt = MyPrompt()
    prompt.prompt = '> '
    prompt.cmdloop('Starting prompt...')
```

## Using prompt_toolkit

- HTTPie + prompt_toolkit = an interactive command-line HTTP client featuring autocomplete and syntax highlighting
https://github.com/eliangcs/http-prompt/tree/master/http_prompt

- 4 Python libraries for building great command-line user interfaces
[Sample code](https://opensource.com/article/17/5/4-practical-python-libraries)
[Project implement to mysql](https://github.com/dbcli/mycli)


# Snippets

## IpAddress & Integer

Python 3 has ipaddress module which features very simple conversion:

    import ipaddress
    int(ipaddress.IPv4Address("192.168.0.1"))
    str(ipaddress.IPv4Address(3232235521))

# Built-In Types

## List (string also list)

### [list operate][5]

```python
    a[start:end] # items start through end-1
    a[start:]    # items start through the rest of the array
    a[:end]      # items from the beginning through end-1
    a[:]         # a copy of the whole array
```

There is also the step value, which can be used with any of the above:

    a[start:end:step] # start through not past end, by step

The key point to remember is that the :end value represents the first value that is not in the selected slice. So, the difference beween end and start is the number of elements selected (if step is 1, the default).


The other feature is that start or end may be a negative number, which means it counts from the end of the array instead of the beginning. So:

    a[-1]    # last item in the array
    a[-2:]   # last two items in the array
    a[:-2]   # everything except the last two items

Python is kind to the programmer if there are fewer items than you ask for. For example, if you ask for a[:-2] and a only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.


Enumerating the possibilities allowed by the grammar:

    >>> seq[:]                # [seq[0],   seq[1],          ..., seq[-1]    ]
    >>> seq[low:]             # [seq[low], seq[low+1],      ..., seq[-1]    ]
    >>> seq[:high]            # [seq[0],   seq[1],          ..., seq[high-1]]
    >>> seq[low:high]         # [seq[low], seq[low+1],      ..., seq[high-1]]
    >>> seq[::stride]         # [seq[0],   seq[stride],     ..., seq[-1]    ]
    >>> seq[low::stride]      # [seq[low], seq[low+stride], ..., seq[-1]    ]
    >>> seq[:high:stride]     # [seq[0],   seq[stride],     ..., seq[high-1]]
    >>> seq[low:high:stride]  # [seq[low], seq[low+stride], ..., seq[high-1]]

Of course, if (high-low)%stride != 0, then the end point will be a little lower than high-1.


Extended slicing (with commas and ellipses) are mostly used only by special data structures (like Numpy); the basic sequences don't support them.

    >>> class slicee:
    ...     def __getitem__(self, item):
    ...         return `item`
    ...
    >>> slicee()[0, 1:2, ::5, ...]
    '(0, slice(1, 2, None), slice(None, None, 5), Ellipsis)'


## string

### trim

If you want to remove leading and ending spaces, use str.strip() :

    sentence = ' hello  apple'
    sentence.strip()
    >>> 'hello  apple'

If you want to remove all spaces, you can use str.replace():

    sentence = ' hello  apple'
    sentence.replace(" ", "")
    >>> 'helloapple'

If you want to remove duplicated spaces, use the str.split():

    sentence = ' hello  apple'
    " ".join(sentence.split())
    >>> 'hello apple'

### empty test

    if not myString:

## I/O oper


python open does not create file if it doesnt exist:

```python
    # Change "rw" to "w+", Or use 'a+' for appending (not erasing existing content)
    file = open('myfile.dat', 'rw')

    # create path
    filename = "/foo/bar/baz.txt"
    if not os.path.exists(os.path.dirname(filename)):
        os.makedirs(os.path.dirname(filename))
    with open(filename, "w+") as f:
        f.write("FOOBAR")
```

# enum

## python 3: already added

Enums have been added to Python 3.4 as described in PEP 435. ie.

```python

    from enum import Enum
    Animal = Enum('Animal', 'ant bee cat dog')

    # or equivalently:
    class Animals(Enum):
        ant = 1
        bee = 2
        cat = 3
        dog = 4
```

## python 2

In earlier versions, one way of accomplishing enums is:
```python

def enum(**enums):
    """
    >>> Numbers = enum(ONE=1, TWO=2, THREE='three')
    >>> Numbers.ONE
    1
    >>> Numbers.TWO
    2
    >>> Numbers.THREE
    'three'
    """
    return type('Enum', (), enums)
```

You can also easily support automatic enumeration with something like this:
```python

    def enum(*sequential, **named):
        enums = dict(zip(sequential, range(len(sequential))), **named)
        return type('Enum', (), enums)

    # Support for converting the values back to names can be added this way:
    def enum(*sequential, **named):
        enums = dict(zip(sequential, range(len(sequential))), **named)
        reverse = dict((value, key) for key, value in enums.iteritems())
        enums['reverse_mapping'] = reverse
        return type('Enum', (), enums)
```


This overwrites anything with that name, but it is useful for rendering your enums in output. It will throw KeyError if the reverse mapping doesn't exist. With the first example:
and used like so:

from name to int
>>> Numbers = enum('ZERO', 'ONE', 'TWO')
>>> Numbers.ZERO
0
>>> Numbers.ONE
1


from enum to name
>>> Numbers.reverse_mapping[Numbers.ONE]
'ONE'

## python 2: My prefer implement use dict
```python

def numbers_to_strings(argument):
    switcher = {
        0: "zero",
        1: "one",
        2: "two",
    }
    return switcher.get(argument, "nothing")

This code is analogous to:

function(argument){
    switch(argument) {
        case 0:
            return "zero";
        case 1:
            return "one";
        case 2:
            return "two";
        default:
            return "nothing";
    };
};
```
While the Python code is often more terse than the standard method of handling cases, I could argue it is more arcane. When I first started Python it felt weird and distracting. Over time it grew on me, the use of a dictionary key being the identifier in a switch becoming more and more habitual.

## Dictionary Mapping for Functions

In Python we can also include functions or lambdas in our dictionary mapping:
```python

def zero():
    return "zero"

def one():
    return "one"

def numbers_to_functions_to_strings(argument):
    switcher = {
        0: zero,
        1: one,
        2: lambda: "two",
    }
    # Get the function from switcher dictionary
    func = switcher.get(argument, lambda: "nothing")
    # Execute the function
    return func()
```

While the code inside zero() and one are simple, many Python programs use dictionary mappings like this to dispatch complex procedures.

## Dispatch Methods for Classes

If we don't know what method to call on a class, we can use a dispatch method to determine it at runtime.
```python

class Switcher(object):
    def numbers_to_methods_to_strings(self, argument):
        """Dispatch method"""
        # prefix the method_name with 'number_' because method names
        # cannot begin with an integer.
        method_name = 'number_' + str(argument)
        # Get the method from 'self'. Default to a lambda.
        method = getattr(self, method_name, lambda: "nothing")
        # Call the method as we return it
        return method()

    def number_0(self):
        return "zero"

    def number_1(self):
        return "one"

    def number_2(self):
        return "two"
```

# Class idioms

To understand why what you wrote failed, you need to know a little bit about how class definitions work in Python. As you may know, Python is an interpreted language: there is a program which reads through Python files and executes them as it goes. When the interpreter encounters a class definition, it does the following:

Creates a new namespace (record of all the variable names) in which the class variables and methods will be stored.
Extracts all the code within the class definition (as determined by its indentation) and runs that code. This will populate the namespace which it just created.
Creates a new class object whose namespace is that given above, and with base classes those given in the definition.
Binds the name of the class to this object.
So what happened when you indented the main function inside your code? While inside step 2, you referred to the name Animal. But this name isn't defined until step 4! Indeed, it can't be defined at the stage you referred to it, because that would be circular. When you move main outside of the class definition, it won't be executed until after steps 1-4 have been completed, and hence the name Animal will already be bound.

By the way, the code you have written is not good Python. You should probably try to find a better tutorial; the usual recommendation is "Dive Into Python". I've rewritten it as it should be done:

## define style

### Style 1: easier like C, I perfer

```python
  class Animal(object):
      def __init__(self, hungry="yes", name=None, owner=None):
          self.hungry = hungry
          self.name = name
          self.owner = owner


      def noise(self):
          print('errr')


      def _internal_method(self):
          print("hard to find")


  if  __name__ =='__main__':
      dog = Animal()
      dog.owner = 'Sue'
      print dog.owner
      dog.noise()
```

### Style 2: more like Java

```python
class Animal:
    __hungry = "yes"
    __name = "no name"
    __owner = "no owner"

    def __init__(self):
        pass

    def set_owner(self,newOwner):
        self.__owner= newOwner
        return

    def get_owner(self):
        return self.__owner

    def set_name(self,newName):
        self.__name= newName
        return

    def get_name(self):
        return self.__name

    def noise(self):
        print('errr')
        return

    def __hiddenmethod(self):
        print("hard to find")

def main():        # should not be in the class. When you take it outside (no indent) it should work.
    dog = Animal()
    dog.set_owner('Sue')
    print dog.get_owner()
    dog.noise()

if  __name__ =='__main__':
    main()
```

## class member & static member

Both ways aren't correct or incorrect, they are just two different kind of class elements:


Elements outside the __init__ method are static elements, it means, they belong to the class, and share by all instance, we can access it event use ClassName.
Elements inside the __init__ method are elements of the object (self), but every object have their independable memory event they have same value, we must by object to access it.

You'll see it more clearly with some code:

```python
    class MyClass:
        static_elem = 123

        def __init__(self):
            self.object_elem = 456

        def setup():
            """
            >>> print c1.static_elem, c1.object_elem
            123 456
            >>> print c2.static_elem, c2.object_elem
            123 456

            # Let's try changing the static element
            MyClass.static_elem = 999
            >>> print c1.static_elem, c1.object_elem
            999 456
            >>> print c2.static_elem, c2.object_elem
            999 456

            # Now, let's try changing the object element
            >>> c1.object_elem = 888
            >>> print c1.static_elem, c1.object_elem
            999 888
            >>> print c2.static_elem, c2.object_elem
            999 456
            # As you can see, when we changed the class element, it changed for both objects.
            # But, when we changed the object element, the other object remained unchanged.
            """

            c1 = MyClass()
            c2 = MyClass()

    if  __name__ =='__main__':
        main()

    if __name__ == os.path.splitext(os.path.basename(__file__))[0]:
        setup()
```
## class static method

    class MyClass(object):
        @staticmethod
        def the_static_method(x):
            print x

    MyClass.the_static_method(2) # outputs 2


## class inheritage


This simple example will show you how to inherit a class from a parent class. I have to apologise for some grammar mistakes that I've probably put in the comments, but English is not my native language.

output:

    Here comes Lois Lane
    Here comes Jimmy Olsen
    Here comes Clark Kent
    ...but his secret identity is 'Superman' and he's a super-hero!
    --> Let's see what a man can do:
    Jimmy Olsen walks
    Lois Lane says: 'Oh no, we're in danger!'
    --> Let's see what a superman can do:
    Clark Kent walks
    Clark Kent says: 'This is a job for SUPERMAN!'
    Superman run at the speed of light
    Superman fly up in the sky
    Superman uses his x-ray vision

```python
    #!/usr/bin/env python

    class man(object):

        # name of the man
        name = ""

        def __init__(self, P_name):
            """ Class constructor """
            self.name = P_name
            print("Here comes " + self.name)

        def talk(self, P_message):
            print(self.name + " says: '" + P_message + "'")

        def walk(self):
            """ This let an instance of a man to walk """
            print(self.name + " walks")

    # This class inherits from Man class
    # A superman has all the powers of a man (A.K.A. Methods and Properties in our case ;-)
    class superman(man):

        # Name of his secret identity
        secret_identity = ""

        def __init__(self, P_name, P_secret_identity):
            """ Class constructor that overrides its parent class constructor"""
            # Invokes the class constructor of the parent class #
            super(superman, self).__init__(P_name)
            # Now let's add a secret identity
            self.secret_identity = P_secret_identity
            print("...but his secret identity is '" + self.secret_identity + "' and he's a super-hero!")

        def walk(self, P_super_speed = False):
            # Overrides the normal walk, because a superman can walk at a normal
            # pace or run at the speed of light!
            if (not P_super_speed): super(superman, self).walk()
            else: print(self.secret_identity + " run at the speed of light")

        def fly(self):
            """ This let an instance of a superman to fly """
            # No man can do this!
            print(self.secret_identity + " fly up in the sky")

        def x_ray(self):
            """ This let an instance of a superman to use his x-ray vision """
            # No man can do this!
            print(self.secret_identity + " uses his x-ray vision")


    # Declare some instances of man and superman
    lois = man("Lois Lane")
    jimmy = man("Jimmy Olsen")
    clark = superman("Clark Kent", "Superman")

    # Let's puth them into action!

    print("\n--> Let's see what a man can do:\n")
    jimmy.walk()
    lois.talk("Oh no, we're in danger!")

    print("\n--> Let's see what a superman can do:\n")
    clark.walk()
    clark.talk("This is a job for SUPERMAN!")
    clark.walk(True)
    clark.fly()
    clark.x_ray()
```

### What does `if __name__ == "__main__":` do?


When the Python interpreter reads a source file, it executes all of the code found in it. Before executing the code, it will define a few special variables. For example, if the python interpreter is running that module (the source file) as the main program, it sets the special __name__ variable to have a value "__main__". If this file is being imported from another module, __name__ will be set to the module's name.

In the case of your script, let's assume that it's executing as the main function, e.g. you said something like

    python threading_example.py

on the command line. After setting up the special variables, it will execute the import statement and load those modules. It will then evaluate the def block, creating a function object and creating a variable called myfunction that points to the function object. It will then read the if statement and see that __name__ does equal "__main__", so it will execute the block shown there.

One of the reasons for doing this is that sometimes you write a module (a .py file) where it can be executed directly. Alternatively, it can also be imported and used in another module. By doing the main check, you can have that code only execute when you want to run the module as a program and not have it execute when someone just wants to import your module and call your functions themselves.

# Use of *args and **kwargs

[The syntax is the `*` and `**`][1].  The names `*args` and `**kwargs` are only by convention but there's no hard requirement to use them.

You would use `*args` when you're not sure how many arguments might be passed to your function, i.e. it allows you pass an arbitrary number of arguments to your function.  For example:

    >>> def print_everything(*args):
            for count, thing in enumerate(args):
    ...         print( '{0}. {1}'.format(count, thing))
    ...
    >>> print_everything('apple', 'banana', 'cabbage')
    0. apple
    1. banana
    2. cabbage

Similarly, `**kwargs` allows you to handle named arguments that you have not defined in advance:

    >>> def table_things(**kwargs):
    ...     for name, value in kwargs.items():
    ...         print( '{0} = {1}'.format(name, value))
    ...
    >>> table_things(apple = 'fruit', cabbage = 'vegetable')
    cabbage = vegetable
    apple = fruit

You can use these along with named arguments too.  The explicit arguments get values first and then everything else is passed to `*args` and `**kwargs`.  The named arguments come first in the list.  For example:

    def table_things(titlestring, **kwargs)

You can also use both in the same function definition but `*args` must occur before `**kwargs`.

You can also use the `*` and `**` syntax when calling a function.  For example:

    >>> def print_three_things(a, b, c):
    ...     print( 'a = {0}, b = {1}, c = {2}'.format(a,b,c))
    ...
    >>> mylist = ['aardvark', 'baboon', 'cat']
    >>> print_three_things(*mylist)
    a = aardvark, b = baboon, c = cat

As you can see in this case it takes the list (or tuple) of items and unpacks it. By this it matches them to the arguments in the function.  Of course, you could have a `*` both in the function definition and in the function call.

  [1]: http://docs.python.org/tutorial/controlflow.html#arbitrary-argument-lists

## parameters ** (double star/asterisk)

[What does ** (double star/asterisk) and * (star/asterisk) do for parameters?](https://stackoverflow.com/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters)

The `*args` and `**kwargs` is a common idiom to allow arbitrary number of arguments to functions as described in the section [more on defining functions][1] in the Python documentation.

The `*args` will give you all function parameters [as a tuple][2]:

```python
    In [1]: def foo(*args):
       ...:     for a in args:
       ...:         print a
       ...:
       ...:

    In [2]: foo(1)
    1


    In [4]: foo(1,2,3)
    1
    2
    3
```
The `**kwargs` will give you all
**keyword arguments** except for those corresponding to a formal parameter as a dictionary.

```python
    In [5]: def bar(**kwargs):
       ...:     for a in kwargs:
       ...:         print a, kwargs[a]
       ...:
       ...:

    In [6]: bar(name='one', age=27)
    age 27
    name one
```
Both idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:

    def foo(kind, *args, **kwargs):
       pass

Another usage of the `*l` idiom is to **unpack argument lists** when calling a function.

```python
    In [9]: def foo(bar, lee):
       ...:     print bar, lee
       ...:
       ...:

    In [10]: l = [1,2]

    In [11]: foo(*l)
    1 2
```
In Python 3 it is possible to use `*l` on the left side of an assignment ([Extended Iterable Unpacking][3]), though it gives a list instead of a tuple in this context:

```python
    first, *rest = [1,2,3,4]
    first, *l, last = [1,2,3,4]
```
Also Python 3 adds new semantic (refer [PEP 3102](https://www.python.org/dev/peps/pep-3102/)):

    def func(arg1, arg2, arg3, *, kwarg1, kwarg2):
        pass

Such function accepts only 3 positional arguments, and everything after `*` can only be passed as keyword arguments.

## pass multiple argument

It's also worth noting that you can use `*` and `**` when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function:

```python
    def foo(x,y,z):
        print("x=" + str(x))
        print("y=" + str(y))
        print("z=" + str(z))
```
You can do things like:

```python
    >>> mylist = [1,2,3]
    >>> foo(*mylist)
    x=1
    y=2
    z=3

    >>> mydict = {'x':1,'y':2,'z':3}
    >>> foo(**mydict)
    x=1
    y=2
    z=3

    >>> mytuple = (1, 2, 3)
    >>> foo(*mytuple)
    x=1
    y=2
    z=3
```
Note: The keys in `mydict` have to be named exactly like the parameters of function `foo`. Otherwise it will throw a `TypeError`:

```python
    >>> mydict = {'x':1,'y':2,'z':3,'badnews':9}
    >>> foo(**mydict)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: foo() got an unexpected keyword argument 'badnews'
```

# Design Pattern: Observer

Well... actually, this looks like a good design to me if an asynchronous API is what you want. It usually is. Maybe all you need is to switch from stderr to Python's [`logging`][1] module, which has a sort of publish/subscribe model of its own, what with `Logger.addHandler()` and so on.

If you do want to support observers, my advice is to keep it simple. You really only need a few lines of code.

```python
    class Event(object):
        pass

    class Observable(object):
        def __init__(self):
            self.callbacks = []
        def subscribe(self, callback):
            self.callbacks.append(callback)
        def fire(self, **attrs):
            e = Event()
            e.source = self
            for k, v in attrs.iteritems():
                setattr(e, k, v)
            for fn in self.callbacks:
                fn(e)
```

Your Job class can subclass `Observable`. When something of interest happens, call `self.fire(type="progress", percent=50)` or the like.


# TroubleShooting

## unittest: doctest

Doctest will parse the while script and then execute the doctest part, sample with filename onetest.py

```python
    class Something:
        Linux, DutKVM, DutOS, DutX, DutNone = range(5)

        @staticmethod
        def echoStr(t):
            """
            >>> dog.owner
            'Sue'
            """
            return "hello"


    class Animal:
        hungry = "yes"
        name = "no name"
        owner = "no owner"

        def __init__(self):
            pass


    # the doctest have __name__ of the current file without extention
    if __name__ == os.path.splitext(os.path.basename(__file__))[0]:
        dog = Animal()
        dog.owner = 'Sue'
```

## trace: echo each line when run

    $ python -m trace --trace my_script.py | grep my_script.py

# Lambda

Like `f = lambda x: x**2 + 2*x - 5`:
            |   |  ---------------
        function|            |
            the 1st param    |
                         the function implement


Python supports a style of programming called functional programming where you can pass functions to other functions to do stuff. Example:

```python
    # sets mult3 to [3, 6, 9], those elements of the original list that are multiples of 3.
    def filterfunc(x):
        return x % 3 == 0
    mult3 = filter(filterfunc, [1, 2, 3, 4, 5, 6, 7, 8, 9])

    # This is shorter (and, one could argue, clearer) than
    mult3 = filter(lambda x: x % 3 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9])
```

Define a function that takes a mark and returns a human readable representation, you can use larsmans's expression or this one:

```python
    # Use string.format to format each entry and map to iterate over all of them:
    def grade(i):
        if i<40: return "Fail"
        if i>75: return "A++"
        if i>50: return "A"

    li = map(lambda x: "{0} - {1}".format(x, grade(x)), s)

    # The resulting list now contains strings in the desired format.

    >>> for i in li: print i
    50 - None
    62 - A
    15 - Fail
    76 - A++
    57 - A
    97 - A++
    82 - A++
    99 - A++
    45 - None
    23 - Fail
```

## unnamed var

The `_` is variable name. Try it. (This variable name is usually a name for an ignored variable. A placeholder so to speak.)

`l = lambda _: True`:
      |    |  ---------------
  function |           |
      the 1st param    |  -> but we don't use this parameter, so just like placeholder.
                   the function implement, always return true


```python
>>> l = lambda _: True
>>> l()
  <lambda>() missing 1 required positional argument: '_'

  >>> l("foo")
  True

# So this lambda does require one argument. If you want a lambda with no argument that always returns True, do this:
>>> m = lambda: True
>>> m()
  True

```

# Import package and module

File structure:
```sh
\
util                                <<< package
  utils.py                          <<< modules
modules                             <<< package, if the dir have __init__.py
  __init__.py
  modules1.py                       <<< modules
  submodule
     __init__.py
     submodule.py
```

for example, now I run the python interpreter in \ level, how to import modules utils.py?

## insert path

By default, you can't. When importing a file, Python only searches the current directory,
the directory that the entry-point script is running from,
and sys.path which includes locations such as the package installation directory
(it's actually a little more complex than this, but this covers most cases).

However, you can add to the Python path at runtime:

    # some_file.py
    import sys
    sys.path.insert(0, '/path/to/application/app/folder')

    import file


## What is __init__.py for?


Files name __init__.py are used to mark directories on disk as Python package directories. If you have the files

mydir/spam/__init__.py
mydir/spam/module.py

and mydir is on your path, you can import the code in module.py as
```python
    import spam.module

    or

    from spam import module
```

If you remove the __init__.py file, Python will no longer look for submodules inside that directory, so attempts to import the module will fail.
The __init__.py file is usually empty, but can be used to export selected portions of the package under more convenient name, hold convenience functions, etc.

Given the example above, the contents of the init module can be accessed as

```python
    import spam
```

## How to use __init__.py


The vast majority of the __init__.py files I write are empty, because many packages don't have anything to initialize.
One example in which I may want initialization is when at package-load time I want to read in a bunch of data once and for all (from files, a DB, or the web, say)
    -- in which case it's much nicer to put that reading in a private function in the package's __init__.py
    rather than have a separate "initialization module" and redundantly import that module from every single real module in the package (uselessly repetitive and error-prone: that's obviously a case in which relying on the language's guarantee that the package's __init__.py is loaded once before any module in the package is obviously much more Pythonic!).

For other concrete and authoritative expressions of opinion,
    look at the different approaches taken in the various packages that are part of Python's standard library.




## Import a module from a relative path


How do I import a python module given its relative path?


For example, if dirFoo contains Foo.py and dirBar, and dirBar contains Bar.py, how do I import Bar.py into Foo.py?


Here's a visual representation:


dirFoo\
    Foo.py
    dirBar\
        Bar.py
Foo wishes to include Bar, but restructuring the folder heirarchy is not an option.


Answer:


Assuming that both your directories are real python packages (do have the __init__.py file inside them), here is a safe solution for inclusion of modules relatively to the location of the script.


I assume that you want to do this because you need to include a set of modules with your script. I use this in production in several products and works in many special scenarios like: scripts called from another directory or executed with python execute instead of opening a new interpreter.


 import os, sys, inspect
 # realpath() with make your script run, even if you symlink it :)
 cmd_folder = os.path.realpath(os.path.abspath(os.path.split(inspect.getfile( inspect.currentframe() ))[0]))
 if cmd_folder not in sys.path:
     sys.path.insert(0, cmd_folder)


 # use this if you want to include modules from a subforder
 cmd_subfolder = os.path.realpath(os.path.abspath(os.path.join(os.path.split(inspect.getfile( inspect.currentframe() ))[0],"subfolder")))
 if cmd_subfolder not in sys.path:
     sys.path.insert(0, cmd_subfolder)


 # Info:
 # cmd_folder = os.path.dirname(os.path.abspath(__file__)) # DO NOT USE __file__ !!!
 # __file__ fails if script is called in different ways on Windows
 # __file__ fails if someone does os.chdir() before
 # sys.argv[0] also fails because it doesn't not always contains the path
As a bonus, this approach does let you force Python to use your module instead of the ones installed on the system.


Warning! I don't really know what is happening when current module is inside an egg file. Probably it fails too. Add a comment if you really need a better solution, I may invest few more hours in improving it.




import package
If you are developping a python package (what you are obviously doing, as you have __init__.py), then the most simple way to import your module is just via the package. For example, if your package is called mypackage, then:


import mypackage.utils


Another sample:


FooPackage/
  __init__.py
  foo.py


import the submodule:
import FooPackage.foo


What you're doing is looking for foo in FooPackage/__init__.py. You could solve it by putting import FooPackage.foo as foo (or from . import foo) in FooPackage/__init__.py, then Python will be able to find foo there. But I recommend using my first suggestion.


When you import FooPackage, Python searches the directories on PYTHONPATH until it
* finds a file called FooPackage.py
* or a directory called FooPackage containing a file called __init__.py
However, having found the package directory, it does not then scan that directory and automatically import all .py files. There are two reasons for this behaviour.
* The first is that importing a module executes Python code which may take time, memory, or have side effects. So you might want to import a.b.c.d without necessarily importing all of a huge package a. It's up to the package designer to decide whether a's __init__.py explicitly imports its modules and subpackages so that they are always available, or whether or leaves the client program the ability to pick and choose what is loaded.
* The second is a bit more subtle, and also a showstopper. Without an explicit import statement (either in FooPackage/__init__.py or in the client program), Python doesn't necessarily know what name it should import foo.py as. On a case insensitive file system (such as used in Windows), this could represent a module named foo, Foo, FOO, fOo, foO, FoO, FOo, or fOO. All of these are valid, distinct Python identifiers, so Python just doesn't have enough information from the file alone to know what you mean. Therefore, in order to behave consistently on all systems, it requires an explicit import statement somewhere to clarify the name, even on file systems where full case information is available.


## how to find module source-code's path

### method 1: __file__

For modules coming from .py (or .pyc) files, you can use mymodule.__file__, e.g.

> import random
> random.__file__
'C:\\Python25\\lib\\random.pyc'


### method 2: python -v

Running python -v from the command line should tell you what is being imported and from where. This works for me on Windows and Mac OS X.

```
    C:\>python -v
    # installing zipimport hook
    import zipimport # builtin
    # installed zipimport hook
    # C:\Python24\lib\site.pyc has bad mtime
    import site # from C:\Python24\lib\site.py
    # wrote C:\Python24\lib\site.pyc
```

# What's the python __all__ module level variable for?

It has two purposes:
  - Anybody who reads the source will know what the exposed public API is. It doesn't prevent them from poking around in private declarations, but does provide a good warning not to.
  - When using from mod import *, only names listed in __all__ will be imported. This is not as important, in my opinion, because importing everything is a really bad idea.

Linked to, but not explicitly mentioned here, is exactly when __all__ is used. It is a list of strings defining what symbols in a module will be exported when from <module> import * is used on the module.


For example, the following code in a foo.py explicitly exports the symbols bar and baz:

```python
    __all__ = ['bar', 'baz']

    waz = 5
    bar = 10

    def baz():
        return 'baz'

    # These symbols can then be imported like so:
    from foo import *

    print bar
    print baz

    # The following will trigger an exception, as "waz" is not exported by the module
    print waz
```

If the __all__ above is commented out, this code will then execute to completion, as the default behaviour of import * is to import all symbols that do not begin with an underscore, from the given namespace.

It's important to note that __all__ only affects the behavior of from <module> import *. Members that are not mentioned in __all__ as still accessible from outside the module and can be imported with from <module> import <member>.

# Mix

## Python's state machine

http://www.ibm.com/developerworks/linux/library/l-python-state/index.html
http://code.activestate.com/recipes/578344-simple-finite-state-machine-class-v2/
https://github.com/oxplot/fysom/blob/master/fysom.py


  [1]: http://python4java.necaiseweb.org/Main/TableOfContents
  [2]: http://www.pycopia.net/
  [3]: http://infinitemonkeycorps.net/docs/pph/
  [4]: http://docs.python-guide.org/en/latest/writing/structure/
  [5]: http://effbot.org/zone/python-list.htm

