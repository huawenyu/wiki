---
layout: post
date:   2014-02-17 13:31:01 +0800
categories: network
tags: develop, network
title:  "Linux iptables实例分析"
---

* content
{:toc}


# iptables管理命令

## 使用的语法

iptables [-t table] 操作 chain RULE

  - 如果想查看特别的表时使用-t指定,如果查看单独的链需要在操作后面指定.
  - 如果是查看规则定义,使用-S. -S比-L查看规则时更加清晰.
  - 如果查看匹配状况使用-nvL.配合watch使用.
  - --line-number用于查看规则号.

## 查看规则

    iptables -nL
    iptables -n -L
    iptables --numeric --list
    iptables -S
    iptables --list-rules
    iptables -t nat -nL
    iptables-save

-n代表--numeric，意思是IP和端口都以数字形式打印出来。否则会将127.0.0.1:80输出成localhost:http。端口与服务的对应关系可以在/etc/services中查看。  
-L代表--list，列出iptables规则，默认列出filter链中的规则，可以用-t来指定列出哪个表中的规则。  
-t代表--tables，指定一个表。  
-S代表--list-rules，以原命令格式列出规则。  
iptables-save命令是以原命令格式列出所有规则，可以-t指定某个表。

## 清除规则

    iptables -F
    iptables --flush
    iptables -F OUTPUT
    iptables -t nat -F
    iptables -t nat -F PREROUTING

-F代表--flush，清除规则，其后面可以跟着链名，默认是将指定表里所有的链规则都清除。

## 自定义连

如果想自行定义规则链,可以通过-N参数,然后通过-j/--jump跳转过来就可以了.

    iptables -N 链名
    iptables ... -j 链名

## 保存规则: iptables-save

    /etc/init.d/iptables save

该命令会将iptables规则保存到/etc/sysconfig/iptables文件里面，如果iptable有开机启动的话，开机时会自动将这些规则添加到机器上。

`iptables-save` 这个命令主要是把内存态的规则保存到文件,然后下次启动的时候用iptables-restore来载入规则. 但是这个命令常常用来查看防火墙规则.比iptables用得都多, 主要是输出结果的格式比较紧凑直观.而且能方便的能看到所有表的规则.

    $ sudo iptables-save

    # Generated by iptables-save v1.4.21 on Fri Jul 17 17:46:45 2015
    *mangle
    :PREROUTING ACCEPT [170491:25205613]
    :INPUT ACCEPT [170491:25205613]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [186436:72064133]
    :POSTROUTING ACCEPT [186436:72064133]
    COMMIT
    # Completed on Fri Jul 17 17:46:45 2015
    # Generated by iptables-save v1.4.21 on Fri Jul 17 17:46:45 2015
    *nat
    :PREROUTING ACCEPT [726722:43601168]
    :INPUT ACCEPT [726722:43601168]
    :OUTPUT ACCEPT [17016:1033385]
    :POSTROUTING ACCEPT [17016:1033385]
    :DOCKER - [0:0]
    -A PREROUTING -m addrtype --dst-type LOCAL -j DOCKER
    -A OUTPUT ! -d 127.0.0.0/8 -m addrtype --dst-type LOCAL -j DOCKER
    -A POSTROUTING -s 172.17.0.0/16 ! -d 172.17.0.0/16 -j MASQUERADE
    COMMIT
    # Completed on Fri Jul 17 17:46:45 2015
    # Generated by iptables-save v1.4.21 on Fri Jul 17 17:46:45 2015
    *filter
    :INPUT ACCEPT [5130295:773100722]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [5052679:681817970]
    -A FORWARD -o docker0 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
    -A FORWARD -i docker0 ! -o docker0 -j ACCEPT
    -A FORWARD -i docker0 -o docker0 -j ACCEPT
    COMMIT
    # Completed on Fri Jul 17 17:46:45 2015

输出是分段的,每个段落一个表,*开头后面跟着表名
:开头的行是对链匹配次数的总结,后面跟着统计信息,[数据包:字节数].
后面跟着的是具体规则
最后跟着COMMIT表示一个表的结束

### iptables-save有两个选项:

-t 后面可以指定表明
-c 输出会在每条规则前加上匹配信息

### 如何快速查看iptables的流量匹配?

iptables [-t 表] -L [链] -nv
iptables-save -c
如果想快速的查看规则匹配情况,可以使用上面两条命令.第一条命令较为灵活,可以控制表和链,而且统计信息比较人性化.第二条命令简单. 配合watch能够动态观察.


## 其他内容

iptables命令中的很多选项前面都可以加"!"，意思是“非”。如"! -s 10.0.0.0/8"表示除这个网段以外的源地址，"! --dport 80"表示除80以外的其他端口。

## 实用命令
对了，还有几个在实际中比较实用（也比较受用:-)）的命令参数，写出来供大家参考

    iptables -L -n

这样的列表会跳过linux的domain lookup,有的时候使用iptables -L会比较慢，因为linux会尝试解析ip的域名，真是罗嗦，如果你的dns server比较不爽的话，iptables -L就会让你很不爽，加一个-n参数就好了。列表刷的就出来。当然了，如果你的linux就是做防火墙，建议把nameserver去掉，在 /etc/resolve.conf里面，因为有时候使用route命令也会比较慢列出来，很是不爽。

iptables -L -v
这个命令会显示链中规则的包和流量计数，嘿嘿，看看哪些小子用的流量那么多，用tc限了他。

iptables -t nat -L -vn
查看nat表中的规则。

cat /proc/net/ip_conntrack
查看目前的conntrack，可能会比较多哦，最好加一个|grep "关键字"，看看你感兴趣的链接跟踪

wc -l /proc/net/ip_conntrack
看看总链接有多少条。

iptables-save >/etc/iptables
把当前的所有链备份一下，之所以放到/etc下面叫iptables，因为这样重起机器的时候会自动加载所有的链，经常地备份一下吧，否则如果链多，万一掉电重启，你还是会比较痛苦。

## 转发
之前因为一个网段被封了，因此通过iptables做转发：

代理服务器WAN IP：111.**.**.219，LAN IP：192.168.0.219

内网服务器IP：192.168.0.41

  1.在代理服务器打开转发功能（sysctl.conf）

  2.添加以下规则

      iptables -t nat -A PREROUTING -d 111.**.**.219 -p tcp --dport 9999 -j DNAT --to-destination 192.168.0.41:9999
      iptables -t nat -A POSTROUTING -d 192.168.0.41 -p tcp --dport 9999 -j SNAT --to-source 192.168.0.219



# iptables规则调优策略

优化的核心原则就是减少规则匹配.

## 简化规则

用multiport,iprange模块,简化规则数量,也减少了匹配次数.

## 调整匹配顺序

  - 书写规则顺序的原则,通用匹配放在前面. 配合iptable -t tname -Lnv的观察数据
  - 提前规则的在表的位置.例如将filter表中针对dnat后匹配的规则放到raw中匹配,需要使用没有做dnat的ip.这样减少了很多次匹配.
  - 分层优化,减少匹配顺序.通过自定义的链,来跳转规则.这样就能减少匹配次数了

## NEW,ESTABLISHED,RELATED,INVALID状态

  - NEW: conntrack模块看到的某个连接第一个包，它即将被匹配了。比如，我们看到一个SYN包，是我们所留意的连接的第一个包，就要匹配它。第一个包也可能不是SYN包，但它仍会被认为是NEW状态。
  - ESTABLISHED: 已经注意到两个方向上的数据传输，而且会继续匹配这个连接的包。处于ESTABLISHED状态的连接是非常容易理解的。只要发送并接到应答，连接就是ESTABLISHED的了。一个连接要从NEW变为ESTABLISHED，只需要接到应答包即可，不管这个包是发往防火墙的，还是要由防火墙转发的。ICMP的错误和重定向等信息包也被看作是ESTABLISHED，只要它们是我们所发出的信息的应答。
  - RELATED 当一个连接和某个已处于ESTABLISHED状态的连接有关系时，就被认为是RELATED的了。换句话说，一个连接要想是RELATED的，首先要有一个ESTABLISHED的连接。这个ESTABLISHED连接再产生一个主连接之外的连接，这个新的连接就是RELATED的了，比如ftp的父子链接.
  - 非以上状态的包.

## 一些实例

### tcp通用规则

    # 这条规则能够过滤掉很多类型的端口扫描
    iptables -t filter -A INPUT -p tcp  -m state --state INVALID -j DROP

    # 避免配置很多内部端口通行规则
    iptables -t filter -A INPUT -p tcp -m state --state ESTABLISHED,RELATED -j ACCEPT
    端口扫描

state与recent模块配合使用.30分钟内发起22,21,80以外端口超过10次,认为是portscan.

    iptables -A INPUT -p all -m state --state ESTABLISHED,RELATED -j ACCEPT
    iptables -A INPUT -p all -m state --state NEW -m recent --name port_scan --update --seconds 1800 --hitcount 10 -j DROP
    iptables -A INPUT -p tcp --syn -m state --state NEW -m multiport --dports 22,21,80 -j ACCEPT
    iptables -A INPUT -p all -m recent --name port_scan --set

### 暴力猜解

暴力猜解会发起很多次尝试,主要是在这里下手.

    #pop3猜解
    iptables -A OUTPUT -p tcp --sport 110 -m string --algo bm --string "-ERR Authentication failed." \
                              -m recent --name pop3 \
                              --update --seconds 600 --hicount 6 -j REJECT
    iptables -A OUTPUT -p tcp --sport 110 -m string --algo bm --string "-ERR Authentication failed." \
                              -m recent --name pop3 --set


    #ssh猜解
    iptables -A INPUT -p tcp --syn --dport 22 -m recent --name ssh --update --seconds 600 --hitcount 4 -j DROP
    iptables -A INPUT -p tcp --syn --dport 22 -m recent --name ssh --set

### Syn flood

    modprobe ipt_recent ip_list_tot=16384
    iptables -N SYN_FLOOD
    iptables -A FORWARD -p tcp --syn --dport 80 -m limit --limit 1/m --limit-burst 300 -j ACCEPT
    iptables -A FORWARD -p tcp --syn --dport 80 -j SYN_FLOOD
    iptables -A SYN_FLOOD -p tcp --syn --dport 80 -m recent --name syn_flood --update --second 123 --hitcount 1 -j ACCEPT
    iptables -A SYN_FLOOD -p tcp --syn --dport 80 -m recent --name syn_flood --set
    iptables -A SYN_FLOOD -p tcp --syn --dport 80 -j DROP

也可以通过调整网络子系统的参数来抵御flood攻击:

    net.ipv4.tcp_synack_retries
    net.ipv4.tcp_max_syn_backlog
    net.ipv4.tcp_syncookies

### ip欺骗经典配置

  - 任何进入网络的数据包不能把网络内部的地址作为源地址。
  - 任何进入网络的数据包必须把网络内部的地址作为目的地址。
  - 任何离开网络的数据包必须把网络内部的地址作为源地址。
  - 任何离开网络的数据包不能把网络内部的地址作为目的地址。
  - 任何进入或离开网络的数据包不能把一个私有地址(Private Address)或在RFC1918中列出的属于保留空间(包括10.x.x.x/8、172.16.x.x/12 或192.168.x.x/16 和网络回送地址127.0.0.0/8.)的地址作为源或目的地址。
  - 阻塞任意源路由包或任何设置了IP选项的包。

# iptables tables

## filter表

### filter表INPUT链

怎么处理发往本机的包。

    iptables {-A|-D|-I} INPUT rule-specification
    iptables -A INPUT -s 10.1.2.11 -p tcp --dport 80 -j DROP
    iptables -A INPUT -s 10.1.2.11 -p tcp --dport 80 -j REJECT --reject-with tcp-reset
    iptables -A INPUT -s 10.1.2.11 -p tcp --dport 80 -j ACCEPT

以上表示将从源地址10.1.2.11访问本机80端口的包丢弃（以tcp-reset方式拒绝和接受）。

  -s 表示源地址（--src,--source），其后面可以是一个IP地址（10.1.2.11）、一个IP网段（10.0.0.0/8）、几个IP或网段（192.168.1.11/32,10.0.0.0/8，添加完成之后其实是两条规则）。  
  -d 表示目的地址（--dst,--destination），其后面可以是一个IP地址（10.1.2.11）、一个IP网段（10.0.0.0/8）、几个IP或网段（10.1.2.11/32,10.1.3.0/24，添加完成之后其实是两条规则）。  
  -p 表示协议类型（--protocol），后面可以是tcp, udp, udplite, icmp, esp, ah, sctp, all，其中all表示所有的协议。  
  --sport 表示源端口（--source-port），后面可以是一个端口（80）、一系列端口（80:90，从80到90之间的所有端口），一般在OUTPUT链使用。  
  --dport 表示目的端口（--destination-port），后面可以是一个端口（80）、一系列端口（80:90，从80到90之间的所有端口）。  
  -j 表示iptables规则的目标（--jump），即一个符合目标的数据包来了之后怎么去处理它。常用的有ACCEPT, DROP, REJECT, REDIRECT, LOG, DNAT, SNAT。


    iptables -A INPUT -p tcp --dport 80 -j DROP
    iptables -A INPUT -p tcp --dport 80:90 -j DROP
    iptables -A INPUT -m multiport -p tcp --dports 80,8080 -j DROP

以上表示将所有访问本机80端口（80和90之间的所有端口，80和8080端口）的包丢弃。

-m 匹配更多规则（--match），可以指定更多的iptables匹配扩展。可以是tcp, udp, multiport, cpu, time, ttl等，即你可以指定一个或多个端口，或者本机的一个CPU核心，或者某个时间段内的包。

### filter表OUTPUT链

怎么处理本机向外发的包。

    iptables -A OUTPUT -p tcp --sport 80 -j DROP

以上这条规则意思是不允许访问本机80端口的包出去。即你可以向本机80端口发送请求包，但是本机回应给你的包会被该条规则丢弃。

INPUT链与OUTPUT链用法一样，但是表示的意思不同。

### filter表的FORWARD链

For packets being routed through the box（不知道怎么解释）。

其用法与INPUT链和OUTPUT链类似。

## nat表

nat表有三条链，分别是PREROUTING, OUTPUT, POSTROUTING。

### nat表PREROUTING链

修改发往本机的包。

    iptables -t nat -A PREROUTING -p tcp -d 202.102.152.23 --dport 80 -j DNAT --to-destination 10.67.15.23:8080
    iptables -t nat -A PREROUTING -p tcp -d 202.102.152.23 -j DNAT --to-destination 10.67.15.23

以上这两条规则的意思是将发往IP地址202.102.152.23和端口80的包的目的地址修改为10.67.15.23，目的端口修改为8080。将发往202.102.152.23的其他非80端口的包目的地址修改为10.67.15.23。第二条规则中的-p tcp是可选的，也可以指定其他协议。

其实类似这样的规则一般在路由器上做，路由器上有个公网IP（202.102.152.23），其中有个用户的内网IP（10.67.15.23）想提供外网的web服务，而路由器又不想将公网IP地址绑定到用户机器上，因此就出来了以上的蛋疼规则。

### nat表POSTROUTING链

修改本机向外发的包。

    iptables -t nat -A POSTROUTING -p tcp -s 10.67.15.23 --sport 8080 -j SNAT --to-source 202.102.152.23:80
    iptables -t nat -A POSTROUTING -p tcp -s 10.67.15.23 -j SNAT --to-source 202.102.152.23

以上两条规则的意思是将从IP地址10.67.15.23和端口8080发出的包的源地址修改为202.102.152.23，源端口修改为80。将从10.67.15.23发出的非80端口的包的源地址修改为202.102.152.23。

这两条正好与以上两条PREROUTING共同完成了内网用户想提供外网服务的功能。

其中的--to-destination和--to-source都可以缩写成--to，在DNAT和SNAT中会分别被理解成--to-destination和--to-source。

注： 之所以将内网服务的端口和外网服务的端口写的不一致是因为二者其实真的可以不一致。另外，是否将PREROUTNG中的-d改为域名就可以使用一个公网IP为不同用户提供服务了呢？这个需要哥哥我稍后验证。

### nat表做HA的实例

有两台服务器和三个IP地址，分别是10.1.2.21, 10.1.2.22, 10.1.5.11。假设他们提供的是相同的WEB服务，现在想让他们做HA，而10.1.5.11是他们的VIP。

* 10.1.2.21这台的NAT规则如下：

    iptables -t nat -A PREROUTING -p tcp -d 10.1.2.11 --dport 80 -j DNAT --to-destination 10.1.2.21:80
    iptables -t nat -A POSTROUTING -p tcp -s 10.1.2.21 --sport 80 -j SNAT --to-source 10.1.2.11:80

* 10.1.2.22这台的NAT规则如下：

    iptables -t nat -A PREROUTING -p tcp -d 10.1.2.11 --dport 80 -j DNAT --to-destination 10.1.2.22:80
    iptables -t nat -A POSTROUTING -p tcp -s 10.1.2.22 --sport 80 -j SNAT --to-source 10.1.2.11:80

默认可以认为VIP在10.1.2.21上挂着，那么当这台机器发生故障不能提供服务时，我们可以及时将VIP挂到10.1.2.22上，这样就可以保证服务不中断了。当然我们可以写一个简单的SHELL脚本来完成VIP的检测及挂载，方法非常简单。

注： LVS的实现中貌似有这么一项，还没有深入去研究LVS。

### nat表为虚拟机做内外网联通

宿主机内网IP是10.67.15.183(eth1)，外网IP是202.102.152.183(eth0)，内网网关是10.67.15.1，其上面的虚拟机IP是10.67.15.250(eth1)。

目前虚拟机只能连接内网，其路由信息如下：

    # ip r s
    10.67.15.0/24 dev eth1  proto kernel  scope link  src 10.67.15.250
    169.254.0.0/16 dev eth1  scope link  metric 1003 
    192.168.0.0/16 via 10.67.15.1 dev eth1 
    172.16.0.0/12 via 10.67.15.1 dev eth1 
    10.0.0.0/8 via 10.67.15.1 dev eth1 
    default via 10.67.15.1 dev eth1

若要以NAT方式实现该虚拟机即能连接公网又能连接内网，则该虚拟机路由需要改成以下：

    # ip r s
    10.67.15.0/24 dev eth1  proto kernel  scope link  src 10.67.15.250
    169.254.0.0/16 dev eth1  scope link  metric 1003 
    192.168.0.0/16 via 10.67.15.1 dev eth1 
    172.16.0.0/12 via 10.67.15.1 dev eth1 
    10.0.0.0/8 via 10.67.15.1 dev eth1 
    default via 10.67.15.183 dev eth1

虚拟机连接内网的网关地址也可以写成宿主机内网IP地址。

宿主机上面添加如下NAT规则：

    iptables -t nat -A POSTROUTING -s 10.67.15.250/32 -d 10.0.0.0/8 -j SNAT --to-source 10.67.15.250
    iptables -t nat -A POSTROUTING -s 10.67.15.250/32 -d 172.16.0.0/12 -j SNAT --to-source 10.67.15.250
    iptables -t nat -A POSTROUTING -s 10.67.15.250/32 -d 192.168.0.0/16 -j SNAT --to-source 10.67.15.250
    iptables -t nat -A POSTROUTING -s 10.67.15.250/32 -j SNAT --to-source 202.102.152.183

以上四条规则的意思是将从源地址10.67.15.250发往内网机器上的数据包的源地址改为10.67.15.250。将从源地址10.67.15.250发往公网机器上的数据包的源地址修改为202.102.152.183。

# 实例1: block all ports except for 1962, 999, 12020?

At first you should always flush to be sure whats already defined… nothing

    iptables -F

Then set the default policy of the INPUT chain to DROP if the end is reached and no rule matched:

    iptables -P INPUT DROP

To ensure the loopback is not affacted you should add

    iptables -A INPUT -i lo -p all -j ACCEPT
    iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

to allow all traffic on the lo-if and every incomming traffic for connections you etablished. After that add every rule you need for your services (don't forget to open ssh if you need it! else you're out):

    iptables -A INPUT -p tcp -m tcp --dport 1962 -j ACCEPT 
    iptables -A INPUT -p tcp -m tcp --dport 999 -j ACCEPT 
    iptables -A INPUT -p tcp -m tcp --dport 12020 -j ACCEPT 

A little trick I do to keep myself and others from accidentally drilling holes into the security I finally add:

    iptables -A INPUT -j DROP

This line matches everything for the INPUT chain and the policy should not get anything. advantage of this is even if you add an ACCEPT-rule sometime after initializing your ruleset it will never become checked because everything is droped before. so it ensures you have to keep everything in one place.

For your question the whole thing looks like this in summary:

    iptables -F
    iptables -P INPUT DROP
    iptables -A INPUT -i lo -p all -j ACCEPT
    iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
    iptables -A INPUT -p tcp -m tcp --dport 1962 -j ACCEPT 
    iptables -A INPUT -p tcp -m tcp --dport 999 -j ACCEPT 
    iptables -A INPUT -p tcp -m tcp --dport 12020 -j ACCEPT 
    iptables -A INPUT -j DROP

# 实例2：简单的nat路由器

目的：实现内网中的节点（10.1.1.0/24）可控的访问internet。

## 环境介绍

- linux 2.4 +
- 2个网络接口
    - Lan口:10.1.1.254/24 eth0
    - Wan口:60.1.1.1/24 eth1

## Metho 1: Nat all

### enable forward

    echo 1 > /proc/sys/net/ipv4/ip_forward

    Also edit /etc/sysctl.conf:
      net.ipv4.ip_forward = 0
      to
      net.ipv4.ip_forward = 1
    This essentially tells your kernel to do step one on boot.

### enable NAT

Then you'll need to configure iptables to forward the packets from your internal network, on /dev/eth1,
to your external network on /dev/eth0. You do this will the following commands:

    # /sbin/iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
    # /sbin/iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT
    # /sbin/iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT

## Metho 2: Nat one by one

首先将Lan的节点pc的网关指向10.1.1.254。

确定你的linux的ip配置无误，可以正确的ping通内外的地址。同时用route命令查看linux的本地路由表，确认指定了可用的ISP提供的默认网关。

### 打开linux的转发功能

    sysctl net.ipv4.ip_forward=1

将FORWARD链的默认策略设置为DROP，这样做的目的是做到对内网ip的控制，你允许哪一个访问internet就可以增加一个规则，不在规则中的ip将无法访问internet.

    iptables -P FORWARD DROP

### 确认包和关联包通过

这条规则规定允许任何地址到任何地址的确认包和关联包通过。一定要加这一条，否则你只允许lan IP访问没有用，至于为什么，下面我们再详细说。

    iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT

### SNAT

这条规则做了一个SNAT，也就是源地址转换，将来自10.1.1.0/24的地址转换为60.1.1.1

(Deven：因为是让内网上网，因此对于代理服务器而言POSTROUTING（经过路由之后的包应该要把源地址改变为60.1.1.1，否则包无法返回）)

    iptables -t nat -A POSTROUTING -s 10.1.1.0/24 -j SNAT --to 60.1.1.1

有这几条规则，一个简单的nat路由器就实现了。这时你可以将允许访问的ip添加至FORWARD链，他们就能访问internet了。

比如我想让10.1.1.9这个地址访问internet,那么你就加如下的命令就可以了。

    iptables -A FORWARD -s 10.1.1.9 -j ACCEPT

也可以精确控制他的访问地址,比如我就允许10.1.1.99访问3.3.3.3这个ip

    iptables -A FORWARD -s 10.1.1.99 -d 3.3.3.3 -j ACCEPT

或者只允许他们访问80端口。

    iptables -A FORWARD -s 10.1.1.0/24 -p tcp --dport http -j ACCEPT

更多的控制可以自己灵活去做,或者查阅iptables的联机文档。

# 实例3：端口转发

目的：对内部server进行端口转发实现internet用户访问内网服务器

## 环境介绍

- linux 2.4 +
- 2个网络接口
- Lan口:10.1.1.254/24 eth0
    + Lan内web server: 10.1.1.1:80
    + Lan内ftp server: 10.1.1.2:21
- Wan口:60.1.1.1/24 eth1

同样确认你的linux的各项配置正常，能够访问内外网。

## Filter.FORWARD链的默认策略设置为DROP

    iptables -P FORWARD DROP

## 确认包和关联包的允许通过

    iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT

也需要加入确认包和关联包的允许通过

## Lan's webserver
如果你要把访问60.1.1.1:80的数据包转发到Lan内web server,用下面的命令

    iptables -t nat -A PREROUTING -d 60.1.1.1 -p tcp --dport 80 -j DNAT --to 10.1.1.1:80

## Lan's ftpserver
ftp服务也同样，命令如下：

    iptables -t nat -A PREROUTING -d 60.1.1.1 -p tcp --dport 21 -j DNAT --to 10.1.1.2:21

好了，命令完成了，端口转发也做完了，本例能不能转发呢？不能，为什么呢？我下面详细分析一下。

## 配置失败分析

对于iptables好像往外访问的配置比较容易，而对内的转发似乎就有一些问题了，在一开始的时候我就先说了一些关于netfilter的流程问题，那么我就简单说说做了这些配置之后为什么有可能还不行呢？

能引起这个配置失败的原因有很多，我们一个个的来说：

第一，本例中，我们的FORWARD策略是DROP,那么也就是说，没有符合规则的包将被丢弃，不管内到外还是外到内，我们在这里依然不讨论那个确认包和关联包的问题.
下面我会详细说一下这个东西，那么如何让本例可以成功呢？加入下面的规则。

    iptables -A FORWARD -d 10.1.1.1 -p tcp --dport 80 -j ACCEPT
    iptables -A FORWARD -d 10.1.1.2 -p tcp --dport 21 -j ACCEPT

有没有觉得有一些晕？为什么目的地址是10.xxx而不是60.xxx，人家internet用户不是访问的60.xxx吗？

呵呵，回到上面看看那个图吧，FORWARD链在什么位置上，它是在PREROUTING之后，也就是说当这个包到达FORWARD链的时候，目的地址已经变成10.xxx了，
假如internet用户的请求是这样202.1.1.1:1333-->60.1.1.1:80，在经过了我们的PREROUTING链之后将变成 202.1.1.1:1333-->10.1.1.1:80,
这个时候如果你设置一个目的地址为60.xxx的规则有用吗？
呵呵，这是问题一。这个时候应该可以完成端口转发的访问了，但是有一些时候还是不行？为什么？看问题二。

第二，内网server的ip配置问题，这里我们以web server为例说明一下
（ftp情况有一些特殊，下面我们再详细讨论，说确认包和关联包的时候讨论这个问题），
上面说到，有的时候可以访问了，有的时候却不行，就是这个web server的ip设置问题了，
如果web server没有指定默认的网关，那么在作了上面的配置之后，
web server会收到internet的请求，但是，他不知道往哪里回啊，人家的本地路由表不知道你那个internet的ip: 202.1.1.1该怎么走。
如果你使用截包工具在web server上面察看，你会发现server收到了来自202.1.1.1:1333-->10.1.1.1:80的请求，
由于你没有给web server配置默认网关，它不知道怎么回去，所以就出现了不通的情况。怎么办呢？两个解决方法：

  1. 第一种方法默认网关
     给这个server配置一个默认网关，当然要指向这个配置端口转发的linux,
     本例是10.1.1.254,配置好了，就一定能访问了。
     有一个疑问？难道不需要在FORWARD链上面设置一个允许web server的ip地址访问外网的规则吗？它的包能出去？
       答案是肯定的，能出去。因为我们那一条允许确认包与关联包的规则，否则它是出不去的。

  2. 第二种方法SNAT
     比较麻烦一些，但是对服务器来说这样似乎更安全一些。
     对这个包再作一次SNAT，也就是在POSTROUTING链上添加规则。命令如下：

     iptables -t nat -A POSTROUTING -d 10.1.1.1 -p tcp --dport 80 -j SNAT --to 10.1.1.254

ftp 的方法相同。这条命令不太好懂？？其实很简单，如果使用这条命令，
那么你的web server不需要再设置默认网关，就能收到这个请求，只要他和linux的lan ip地址是能互访的（也就是说web server和Linux的Lan ip在同一个广播域），

我们在根据上面的netfilter流程图来分析这个包到底被我们怎么样了：

  1. 首先一个请求`202.1.1.1:1333--> 60.1.1.1:80`被linux收到了，进入PREROUTING；
  2. 发现一个规则`iptables -t nat -A PREROUTING -d 60.1.1.1 -p tcp --dport 80 -j DNAT --to 10.1.1.1:80`符合，
       好了，改你的目的地址，于是这个包变成了`202.1.1.1:1333-->10.1.1.1:80`，继续往前走；
  3. 进入FORWARD链，okay,也有一条规则允许通过`iptables -A FORWARD -d 10.1.1.1 -p tcp --dport 80 -j ACCEPT`；
  4. 进入route box选路，找到合适的路径了，继续进入POSTROUTING链；
       耶？又发现一个符合的规则`iptables -t nat -A POSTROUTING -d 10.1.1.1 -p tcp --dport 80 -j SNAT --to 10.1.1.254`,
       原来是一个SNAT,改你的源地址，于是这个包变成了`10.1.1.254:xxxx-->10.1.1.1:80`。为什么用xxxx了，这里的端口是随机的，我也不知道会是什么。
       而整个的两次变化的过程都会记录在linux的`ip_conntrack`中；
  5. 当web server收到这个包的时候，发现，原来是一个内网自己兄弟来的请求阿，又在同一个广播域，不用找网关，把返回包直接扔给交换机了；
  6. linux在收到返回包之后，会根据他的`ip_conntrack`中的条目进行两次变换，返回真正的internet用户，于是完成这一次的访问。


## 状态机制`ip_conntrack`

下面我们就说说我一直在上面提到的关于那个ESTABLISHED,RELATED的规则是怎么回事，到底有什么用处。

    iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT

说这个东西就要简单说一下网络的数据通讯的方式，我们知道，网络的访问是双向的，也就是说一个Client与Server之间完成数据交换需要双方的发包与收包。
在netfilter中，有几种状态，也就是new, established,related,invalid。

### ESTABLISHED

当一个客户端，在本文例一中，内网的一台机器访问外网，我们设置了规则允许他出去，但是没有设置允许回来的规则阿，怎么完成访问呢？
这就是netfilter的状态机制:
  1. 当一个lan用户通过这个linux访问外网的时候，它发送了一个请求包，这个包的状态是new,
  2. 当外网回包的时候他的状态就是established,所以，linux知道，哦，这个包是我的内网的一台机器发出去的应答包，他就放行了。
  3. 而外网试图对内发起一个新的连接的时候，他的状态是new,所以linux压根不去理会它。这就是我们为什么要加这一句的原因。

### RELATED

还有那个related,他是一个关联状态，什么会用到呢？
tftp,ftp都会用到，因为他们的传输机制决定了，它不像http访问那样:

    Client_IP: port-->server:80然后server:80-->Client_IP:port

ftp使用tcp21建立连接，使用20端口发送数据，其中又有两种方式:

#### 一种主动active mode

主动模式下，client使用port命令告诉server我用哪一个端口接受数据，然后server主动发起对这个端口的请求。

#### 一种被动passive mode

被动模式下，server使用port命令告诉客户端，它用那个端口监听，然后客户端发起对他的数据传输，
所以这对于一个防火墙来说就是比较麻烦的事情:
因为有可能会有new状态的数据包，但是它又是合理的请求，这个时候就用到这个related状态了，
他就是一种关联，在linux中，有个叫 ftp_conntrack的模块，它能识别port命令，然后对相应的端口进行放行。

# 实验4: 基于filter表的防火墙实例

## (1)Check rules of chain: INPUT,FORWARD,OUTPUT

    [root@tp ~]# iptables -L -n
    Chain INPUT (policy ACCEPT)  Chain INPUT (policy DROP)
    target     prot opt source               destination
    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0
    ACCEPT     tcp  --  192.168.181.34       0.0.0.0/0           tcp dpt:22
    ACCEPT     tcp  --  192.168.181.35       0.0.0.0/0           tcp dpt:22
    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0           tcp dpt:80

    Chain FORWARD (policy DROP)
    target     prot opt source               destination

    Chain OUTPUT (policy DROP)
    target     prot opt source               destination
    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0
    ACCEPT     tcp  --  192.168.181.33       0.0.0.0/0           tcp spt:22

如果你在安装linux时没有选择启动防火墙,则什么规则都没有:

    # iptables -L -n

    Chain INPUT (policy ACCEPT)
    target       prot opt source                 destination
    Chain FORWARD (policy ACCEPT)
    target       prot opt source                 destination
    Chain OUTPUT (policy ACCEPT)
    target       prot opt source                 destination


## (2)清除原有规则

不管你在安装linux时是否启动了防火墙,如果你想配置属于自己的防火墙,
那就清除现在filter的所有规则.

    # iptables -F        清除预设表filter中的所有规则链的规则
    # iptables -X        清除预设表filter中使用者自定链中的规则
    # iptables -Z        清楚预设表filter中计数器

我们在来看一下: `iptables -L -n`
什么都没有了吧,和我们在安装linux时没有启动防火墙是一样的.
(提前说一句,这些配置就像用命令配置IP一样,重起就会失去作用),怎么保存.

    [root@tp ~]# /etc/rc.d/init.d/iptables save

这样就可以写到/etc/sysconfig/iptables文件里了.
写入后记得把防火墙重起一下,才能起作用.

    [root@tp ~]# service iptables restart

现在IPTABLES配置表里什么配置都没有了,那我们开始我们的配置吧

## (3)设定预设规则

到这最好做一个shellscript.

```sh
    # cat ipt.sh

    #!/bin/bash
    #iptables init
    #---------------------------
    iptables -F
    iptables -X
    iptables -Z
    #set the default rules
    #---------------------------
    iptables -P INPUT DROP
    iptables -P OUTPUT DROP
    iptables -P FORWARD DROP

    #---------------------------
    service iptables save
    iptables -L -n

    # bash ./ipt.sh
```

上面的意思是,当超出了IPTABLES里filter表里的两个链规则(INPUT,FORWARD)时,
不在这两个规则里的数据包怎么处理呢,那就是DROP(放弃). 应该说这样配置是很安全的:
  - 我们要控制流入数据包
  - 对于OUTPUT链,也就是流出的包我们不用做太多限制,
    而是采取ACCEPT,也就是说,不在着个规则里的包怎么办呢,那就是通过.

`注`:

如果你是远程SSH登陆的话,当你输入第一个命令回车的时候就应该掉了.
因为你没有设置任何规则. 怎么办,去本机操作呗!

## (4)添加规则

### 首先添加INPUT链

INPUT链的默认规则是DROP,所以我们就写需要ACCETP(通过)的链
为了能采用远程SSH登陆,我们要开启22端口.

```
    # 开启SSH所需要打开22端口
        # 进入INPUT的来源IP, localPC: `192.168.181.34`
        iptables -A INPUT  -s 192.168.181.34 -p tcp --dport 22 -j ACCEPT

        # 出去OUTPUT的来源IP（基本都是本机）, Server: `192.168.181.33`
        iptables -A OUTPUT -s 192.168.181.33 -p tcp --sport 22 -j ACCEPT

    # WEB服务器,开启80端口
    iptables -A INPUT -p tcp --dport 80 -j ACCEPT

    # 邮件服务器,开启25,110端口.
    iptables -A INPUT -p tcp --dport 110 -j ACCEPT
    iptables -A INPUT -p tcp --dport 25 -j ACCEPT

    # FTP服务器,开启21端口
    iptables -A INPUT -p tcp --dport 21 -j ACCEPT
    iptables -A INPUT -p tcp --dport 20 -j ACCEPT

    # DNS服务器,开启53端口
    iptables -A INPUT -p tcp --dport 53 -j ACCEPT
```

如果你还做了其他的服务器,需要开启哪个端口,照写就行了.
上面主要写的都是INPUT链,凡是不在上面的规则里的,都DROP

    # 允许icmp包通过,也就是允许ping
        # IF (OUTPUT设置成DROP的话)
        iptables -A OUTPUT -p icmp -j ACCEPT

        # IF (INPUT设置成DROP的话)
        iptables -A INPUT -p icmp -j ACCEPT

    # 允许loopback!(不然会导致DNS无法正常关闭等问题)
        # (如果是INPUT DROP)
        iptables -A INPUT -i lo -p all -j ACCEPT
        # (如果是OUTPUT DROP)
        iptables -A OUTPUT -o lo -p all -j ACCEPT

### OUTPUT链

OUTPUT链默认规则是ACCEPT,所以我们就写需要DROP(放弃)的链.
当然出入更安全的考虑你也可以包OUTPUT链设置成DROP,那你添加的规则就多一些.

有些些特洛伊木马会扫描端口31337到31340(即黑客语言中的 elite 端口)上的服务。
既然合法服务都不使用这些非标准端口来通信,
阻塞这些端口能够有效地减少你的网络上可能被感染的机器和它们的远程主服务器进行独立通信的机会

    # 减少不安全的端口连接
    iptables -A OUTPUT -p tcp --sport 31337 -j DROP
    iptables -A OUTPUT -p tcp --dport 31337 -j DROP

还有其他端口也一样,像:31335、27444、27665、20034 NetBus、9704、137-139（smb）,2049(NFS)端口也应被禁止,我在这写的也不全.

    下面写一下更加细致的规则,就是限制到某台机器
    如:我们只允许192.168.0.3的机器进行SSH连接
    # iptables -A INPUT -s 192.168.0.3 -p tcp --dport 22 -j ACCEPT

    如果要允许,或限制一段IP地址可用 192.168.0.0/24 表示192.168.0.1-255端的所有IP.
    24表示子网掩码数.但要记得把 /etc/sysconfig/iptables 里的这一行删了.
    -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT 因为它表示所有地址都可以登陆.
    或采用命令方式:
    # iptables -D INPUT -p tcp --dport 22 -j ACCEPT
    然后保存,我再说一边,反是采用命令的方式,只在当时生效,如果想要重起后也起作用,那就要保存.写入到/etc/sysconfig/iptables文件里.
    # /etc/rc.d/init.d/iptables save
    这样写 !192.168.0.3 表示除了192.168.0.3的ip地址
    其他的规则连接也一样这么设置.

### FORWARD链

FORWARD链的默认规则是DROP,所以我们就写需要ACCETP(通过)的链,对正在转发链的监控.

#### 开启转发功能

在做NAT时,`FORWARD默认规则是DROP时`,必须做

    iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT
    iptables -A FORWARD -i eth1 -o eh0 -j ACCEPT

#### 丢弃坏的TCP包

    iptables -A FORWARD -p TCP ! --syn -m state --state NEW -j DROP

#### 处理IP碎片数量,防止攻击,允许每秒100个

    iptables -A FORWARD -f -m limit --limit 100/s --limit-burst 100 -j ACCEPT

#### 设置ICMP包过滤,允许每秒1个包,限制触发条件是10个包.

    iptables -A FORWARD -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT

我在前面只所以允许ICMP包通过,就是因为我在这里有限制.

### 配置NAT表

#### 1,查看本机关于NAT的设置情况

    [root@tp rc.d]# iptables -t nat -L

      Chain PREROUTING (policy ACCEPT)
      target       prot opt source                 destination
      Chain POSTROUTING (policy ACCEPT)
      target       prot opt source                 destination
      SNAT         all    --    192.168.0.0/24         anywhere              to:211.101.46.235
      Chain OUTPUT (policy ACCEPT)
      target       prot opt source                 destination

如果你想清除,命令是

    # iptables -F -t nat
    # iptables -X -t nat
    # iptables -Z -t nat

#### 2,添加规则

添加规则,我们只添加DROP链.因为默认链全是ACCEPT.

    防止外网用内网IP欺骗
    # iptables -t nat -A PREROUTING -i eth0 -s 10.0.0.0/8 -j DROP
    # iptables -t nat -A PREROUTING -i eth0 -s 172.16.0.0/12 -j DROP
    # iptables -t nat -A PREROUTING -i eth0 -s 192.168.0.0/16 -j DROP

## (5)最后 drop非法连接

    # iptables -A INPUT   -m state --state INVALID -j DROP
    # iptables -A OUTPUT  -m state --state INVALID -j DROP
    # iptables -A FORWARD -m state --state INVALID -j DROP

    允许所有已经建立的和相关的连接
    # iptables-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    # iptables-A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    # /etc/rc.d/init.d/iptables save

  [1]: https://www.netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO.txt
  [2]: http://www.docum.org/docum.org/kptd/
  [3]: http://fishcried.com/2016-02-19/iptables/
  [4]: https://gigenchang.wordpress.com/2014/04/19/10%E5%88%86%E9%90%98%E5%AD%B8%E6%9C%83iptables/
  [5]: https://my.oschina.net/HankCN/blog/117796

